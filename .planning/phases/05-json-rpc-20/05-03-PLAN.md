---
phase: 05-json-rpc-20
plan: 03
type: tdd
wave: 3
depends_on: [05-01, 05-02]
files_modified:
  - internal/server/rpc_notify.go
  - internal/server/rpc_notify_test.go
  - internal/server/rpc_methods.go
  - internal/server/web.go
  - internal/server/server.go
autonomous: true
requirements: [RPC-02, RPC-03, RPC-11]

must_haves:
  truths:
    - "WebSocket endpoint at /jsonrpc/ws accepts WebSocket upgrade and serves jrpc2 over the connection (RPC-02)"
    - "WebSocket upgrade at /jsonrpc/ws requires Authorization: Bearer <token> header in the upgrade request (RPC-03)"
    - "WebSocket upgrade without auth token is rejected with HTTP 401 (RPC-03)"
    - "WebSocket client can call RPC methods (e.g., system.getVersion) over the WebSocket connection"
    - "RPCNotifier struct maintains a thread-safe registry of active jrpc2.Server instances (one per WebSocket connection)"
    - "RPCNotifier.Register(server) adds a server to the registry; RPCNotifier.Unregister(server) removes it"
    - "RPCNotifier.Broadcast(method, params) calls server.Push(ctx, method, params) on all registered servers"
    - "Broadcast with method='download.started' sends {gid, fileName, totalLength} to all WebSocket clients (RPC-11)"
    - "Broadcast with method='download.progress' sends {gid, completedLength, speed} to all WebSocket clients (RPC-11)"
    - "Broadcast with method='download.complete' sends {gid, totalLength} to all WebSocket clients (RPC-11)"
    - "Broadcast with method='download.error' sends {gid, error} to all WebSocket clients (RPC-11)"
    - "download.add handler (from 05-02) sets up event callbacks that call notifier.Broadcast for started/progress/complete/error events"
    - "RPCNotifier.Broadcast on a disconnected server does not block or panic -- errors from Push are logged and the server is unregistered"
    - "WebSocket connection accept loop runs in a goroutine started from WebServer.Start()"
    - "WebSocket listener is closed during WebServer.Shutdown() -- no goroutine leaks"
    - "Each WebSocket connection spawns its own jrpc2.Server with AllowPush: true"
    - "WebSocket transport uses coder/websocket (not golang.org/x/net/websocket) for the new /jsonrpc/ws endpoint"
    - "WebSocket auth uses the Authorization header during HTTP upgrade (CheckAccept or manual check before Accept)"
    - "Existing browser capture WebSocket at '/' is unaffected (uses golang.org/x/net/websocket)"
  artifacts:
    - path: "internal/server/rpc_notify.go"
      provides: "RPCNotifier struct with Register/Unregister/Broadcast methods, thread-safe server registry"
      exports: ["RPCNotifier"]
    - path: "internal/server/rpc_notify_test.go"
      provides: "Tests for notifier: register/unregister, broadcast to multiple servers, disconnected server cleanup, concurrent broadcast safety"
    - path: "internal/server/rpc_methods.go"
      provides: "Updated download.add with notifier event callbacks; notifier field on RPCServer"
    - path: "internal/server/web.go"
      provides: "Updated handler() with /jsonrpc/ws route; WebSocket accept loop; updated Shutdown() for listener cleanup"
  key_links:
    - from: "internal/server/rpc_notify.go:RPCNotifier"
      to: "github.com/creachadair/jrpc2:Server.Push"
      via: "Push notifications to connected WebSocket jrpc2 servers"
      pattern: "server\\.Push"
    - from: "internal/server/web.go:handler()"
      to: "github.com/coder/websocket:Accept"
      via: "WebSocket upgrade for /jsonrpc/ws using coder/websocket"
      pattern: "websocket\\.Accept"
    - from: "internal/server/rpc_methods.go:downloadAdd"
      to: "internal/server/rpc_notify.go:RPCNotifier.Broadcast"
      via: "Download event handlers call Broadcast for real-time notifications"
      pattern: "notifier\\.Broadcast"
---

<objective>
Add WebSocket JSON-RPC endpoint at /jsonrpc/ws with auth, implement real-time push notification broadcaster, and wire download event handlers to broadcast notifications to connected WebSocket clients.

Purpose: Plans 05-01 and 05-02 delivered HTTP-only JSON-RPC. This plan adds WebSocket transport for real-time bidirectional communication. Connected WebSocket clients can both call RPC methods AND receive server-push notifications (download.started, download.progress, download.complete, download.error). The notification layer is decoupled from the existing Pool broadcast (which serves CLI binary protocol clients) -- RPC WebSocket clients get their own notification path via RPCNotifier.

Architecture decision: Rather than using `creachadair/wschannel` (which requires Go 1.25 -- see research Pitfall 6), we inline the WebSocket-to-jrpc2 bridge using `coder/websocket` directly. The bridge is ~50 lines: accept WS connection, create a jrpc2 Channel adapter, spawn jrpc2.Server with AllowPush. This avoids the Go 1.25 toolchain requirement.

Output: rpc_notify.go (broadcaster), updated rpc_methods.go (notifier integration), updated web.go (WS endpoint), tests.
</objective>

<execution_context>
@/Users/divkix/.claude/get-shit-done/workflows/execute-plan.md
@/Users/divkix/.claude/get-shit-done/templates/summary.md
@/Users/divkix/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/05-json-rpc-20/05-RESEARCH.md
@.planning/phases/05-json-rpc-20/05-01-PLAN.md
@.planning/phases/05-json-rpc-20/05-02-PLAN.md

@internal/server/rpc_methods.go (from 05-01 + 05-02)
@internal/server/rpc_auth.go (from 05-01)
@internal/server/web.go (from 05-01)
@internal/server/server.go
@internal/server/pool.go
</context>

<interfaces>
<!-- Key types and contracts the executor needs. -->

From github.com/creachadair/jrpc2 v1.3.4:
```go
// Server with push support
srv := jrpc2.NewServer(methods, &jrpc2.ServerOptions{
    AllowPush: true,
})
srv.Start(channel) // Start serving on a Channel

// Push notification to client
err := srv.Push(ctx, "download.progress", params)
// Returns error if client disconnected

// Channel interface
type Channel interface {
    Send([]byte) error
    Recv() ([]byte, error)
    Close() error
}
```

From github.com/coder/websocket v1.8.14:
```go
// Accept WebSocket upgrade (server-side)
conn, err := websocket.Accept(w, r, &websocket.AcceptOptions{
    // DO NOT set OriginPatterns: []string{"*"} -- security risk
})

// Read/Write for building a Channel adapter
msgType, data, err := conn.Read(ctx)
err := conn.Write(ctx, websocket.MessageText, data)
conn.Close(websocket.StatusNormalClosure, "")
```

From internal/server/rpc_methods.go (after 05-02):
```go
type RPCServer struct {
    bridge       *jhttp.Bridge
    manager      *warplib.Manager
    client       *http.Client
    pool         *Pool
    schemeRouter *warplib.SchemeRouter
    // To be added: notifier *RPCNotifier
}
```

WebSocket Channel adapter (inline, replaces wschannel):
```go
// wsChannel wraps a coder/websocket.Conn into a jrpc2.Channel.
type wsChannel struct {
    conn *websocket.Conn
    ctx  context.Context
}

func (c *wsChannel) Send(data []byte) error {
    return c.conn.Write(c.ctx, websocket.MessageText, data)
}

func (c *wsChannel) Recv() ([]byte, error) {
    _, data, err := c.conn.Read(c.ctx)
    return data, err
}

func (c *wsChannel) Close() error {
    return c.conn.Close(websocket.StatusNormalClosure, "")
}
```

Notification event types:
```go
type DownloadStartedNotification struct {
    GID         string `json:"gid"`
    FileName    string `json:"fileName"`
    TotalLength int64  `json:"totalLength"`
}

type DownloadProgressNotification struct {
    GID             string `json:"gid"`
    CompletedLength int64  `json:"completedLength"`
}

type DownloadCompleteNotification struct {
    GID         string `json:"gid"`
    TotalLength int64  `json:"totalLength"`
}

type DownloadErrorNotification struct {
    GID   string `json:"gid"`
    Error string `json:"error"`
}
```
</interfaces>

<feature>
  <name>WebSocket JSON-RPC Endpoint with Real-Time Push Notifications</name>
  <files>internal/server/rpc_notify.go, internal/server/rpc_notify_test.go, internal/server/rpc_methods.go, internal/server/web.go, internal/server/server.go</files>
  <behavior>
    Test cases for RPC-02 (WebSocket endpoint):
    1. WebSocket upgrade at /jsonrpc/ws with valid auth token succeeds
    2. WebSocket client can send system.getVersion request and receive response
    3. WebSocket client can send download.status request and receive response
    4. Multiple WebSocket clients can connect concurrently

    Test cases for RPC-03 (WebSocket auth):
    5. WebSocket upgrade at /jsonrpc/ws without Authorization header is rejected (HTTP 401 or connection refused)
    6. WebSocket upgrade at /jsonrpc/ws with wrong token is rejected

    Test cases for RPC-11 (push notifications):
    7. Connected WebSocket client receives download.started notification when a download begins
    8. Connected WebSocket client receives download.progress notification during download
    9. Connected WebSocket client receives download.complete notification when download finishes
    10. Connected WebSocket client receives download.error notification on download error
    11. Multiple connected WebSocket clients all receive the same notification
    12. Disconnected WebSocket client does not block notification broadcast
    13. RPCNotifier.Broadcast with zero registered servers is a no-op (no panic)
    14. RPCNotifier.Register/Unregister are thread-safe under concurrent access

    Lifecycle:
    15. WebSocket accept loop shuts down when WebServer.Shutdown() is called
    16. jrpc2 servers spawned per WebSocket connection are cleaned up on disconnect
    17. Existing browser capture WebSocket at "/" continues working
  </behavior>
  <implementation>
    PHASE A: Add coder/websocket dependency (if not already present)

    ```bash
    cd /Users/divkix/GitHub/warpdl/.claude/worktrees/issues-fix
    go get github.com/coder/websocket@v1.8.14
    go mod tidy
    ```

    PHASE B: RED -- Write failing tests

    Batch 1: RPCNotifier unit tests (rpc_notify_test.go)
    ```go
    func TestRPCNotifier_RegisterUnregister(t *testing.T) {
        // Create notifier, register a mock server, verify count
        // Unregister, verify count is 0
    }

    func TestRPCNotifier_Broadcast(t *testing.T) {
        // Create notifier with registered mock servers
        // Broadcast a notification
        // Verify all servers received it
    }

    func TestRPCNotifier_BroadcastEmpty(t *testing.T) {
        // Broadcast with no servers: should not panic
    }

    func TestRPCNotifier_ConcurrentAccess(t *testing.T) {
        // Concurrent Register/Unregister/Broadcast from multiple goroutines
        // Verify no race conditions (run with -race)
    }

    func TestRPCNotifier_DisconnectedServer(t *testing.T) {
        // Register server, close it, then broadcast
        // Verify no blocking, error is handled, server is cleaned up
    }
    ```

    Batch 2: WebSocket integration tests (in rpc_methods_test.go or separate rpc_ws_test.go)
    ```go
    func TestRPCWebSocket_Connect(t *testing.T) {
        // Start test HTTP server with handler() mux
        // Connect via coder/websocket.Dial with Authorization header
        // Send system.getVersion, verify response
    }

    func TestRPCWebSocket_NoAuth(t *testing.T) {
        // Try WebSocket upgrade without auth
        // Expect connection rejection
    }

    func TestRPCWebSocket_Notification(t *testing.T) {
        // Connect WS client
        // Trigger notifier.Broadcast("download.progress", ...)
        // Read notification from WS client, verify format
    }
    ```

    PHASE C: GREEN -- Implement rpc_notify.go

    Create internal/server/rpc_notify.go:
    ```go
    package server

    import (
        "context"
        "log"
        "sync"

        "github.com/creachadair/jrpc2"
    )

    // RPCNotifier maintains a set of connected jrpc2 WebSocket servers
    // and broadcasts push notifications to all of them.
    type RPCNotifier struct {
        mu      sync.RWMutex
        servers map[*jrpc2.Server]struct{}
        log     *log.Logger
    }

    // NewRPCNotifier creates a new notifier.
    func NewRPCNotifier(l *log.Logger) *RPCNotifier {
        return &RPCNotifier{
            servers: make(map[*jrpc2.Server]struct{}),
            log:     l,
        }
    }

    // Register adds a server to the broadcast set.
    func (n *RPCNotifier) Register(srv *jrpc2.Server) {
        n.mu.Lock()
        defer n.mu.Unlock()
        n.servers[srv] = struct{}{}
    }

    // Unregister removes a server from the broadcast set.
    func (n *RPCNotifier) Unregister(srv *jrpc2.Server) {
        n.mu.Lock()
        defer n.mu.Unlock()
        delete(n.servers, srv)
    }

    // Broadcast sends a push notification to all registered servers.
    // Servers that fail to receive (e.g., disconnected) are unregistered.
    func (n *RPCNotifier) Broadcast(method string, params any) {
        n.mu.RLock()
        servers := make([]*jrpc2.Server, 0, len(n.servers))
        for srv := range n.servers {
            servers = append(servers, srv)
        }
        n.mu.RUnlock()

        var failed []*jrpc2.Server
        for _, srv := range servers {
            if err := srv.Push(context.Background(), method, params); err != nil {
                n.log.Printf("RPC push failed: %v", err)
                failed = append(failed, srv)
            }
        }

        if len(failed) > 0 {
            n.mu.Lock()
            for _, srv := range failed {
                delete(n.servers, srv)
            }
            n.mu.Unlock()
        }
    }

    // Count returns the number of registered servers (for testing).
    func (n *RPCNotifier) Count() int {
        n.mu.RLock()
        defer n.mu.RUnlock()
        return len(n.servers)
    }
    ```

    Notification param types (in rpc_notify.go or rpc_methods.go):
    ```go
    type DownloadStartedNotification struct {
        GID         string `json:"gid"`
        FileName    string `json:"fileName"`
        TotalLength int64  `json:"totalLength"`
    }

    type DownloadProgressNotification struct {
        GID             string `json:"gid"`
        CompletedLength int64  `json:"completedLength"`
    }

    type DownloadCompleteNotification struct {
        GID         string `json:"gid"`
        TotalLength int64  `json:"totalLength"`
    }

    type DownloadErrorNotification struct {
        GID   string `json:"gid"`
        Error string `json:"error"`
    }
    ```

    PHASE D: GREEN -- Implement wsChannel adapter and WebSocket handler

    Add to web.go (or a new rpc_ws.go):
    ```go
    import (
        "github.com/creachadair/jrpc2"
        "github.com/creachadair/jrpc2/handler"
        cws "github.com/coder/websocket"
    )

    // wsChannel adapts coder/websocket.Conn to jrpc2.Channel.
    type wsChannel struct {
        conn *cws.Conn
        ctx  context.Context
    }

    func (c *wsChannel) Send(data []byte) error {
        return c.conn.Write(c.ctx, cws.MessageText, data)
    }

    func (c *wsChannel) Recv() ([]byte, error) {
        _, data, err := c.conn.Read(c.ctx)
        return data, err
    }

    func (c *wsChannel) Close() error {
        return c.conn.Close(cws.StatusNormalClosure, "")
    }

    // handleJSONRPCWebSocket handles WebSocket upgrade at /jsonrpc/ws.
    // Each connection gets its own jrpc2.Server with AllowPush.
    func (s *WebServer) handleJSONRPCWebSocket(w http.ResponseWriter, r *http.Request) {
        // Auth check before WebSocket upgrade
        token := strings.TrimPrefix(r.Header.Get("Authorization"), "Bearer ")
        if s.rpc == nil || s.rpc.secret == "" ||
            subtle.ConstantTimeCompare([]byte(token), []byte(s.rpc.secret)) != 1 {
            http.Error(w, "Unauthorized", http.StatusUnauthorized)
            return
        }

        conn, err := cws.Accept(w, r, nil)
        if err != nil {
            s.l.Printf("WebSocket accept error: %v", err)
            return
        }

        ctx := r.Context()
        ch := &wsChannel{conn: conn, ctx: ctx}

        // Create jrpc2 server for this connection
        methods := s.rpc.Methods() // Returns handler.Map
        srv := jrpc2.NewServer(methods, &jrpc2.ServerOptions{
            AllowPush: true,
        })

        // Register for notifications
        if s.rpc.notifier != nil {
            s.rpc.notifier.Register(srv)
            defer s.rpc.notifier.Unregister(srv)
        }

        // Serve blocks until connection closes
        srv.Start(ch)
        _ = srv.Wait()
    }
    ```

    Update handler():
    ```go
    func (s *WebServer) handler() http.Handler {
        mux := http.NewServeMux()
        mux.Handle("/", websocket.Handler(s.handleConnection))
        if s.rpc != nil {
            mux.Handle("/jsonrpc", requireToken(s.rpc.secret, s.rpc.bridge))
            mux.HandleFunc("/jsonrpc/ws", s.handleJSONRPCWebSocket)
        }
        return mux
    }
    ```

    PHASE E: GREEN -- Add notifier to RPCServer and wire download.add handlers

    Add notifier field to RPCServer:
    ```go
    type RPCServer struct {
        // ... existing fields ...
        notifier *RPCNotifier
    }
    ```

    Add Methods() helper that returns the handler.Map (needed for per-WS-connection jrpc2.Server):
    ```go
    func (rs *RPCServer) Methods() handler.Map {
        return handler.Map{
            "system.getVersion": handler.New(rs.systemGetVersion),
            "download.add":     handler.New(rs.downloadAdd),
            "download.pause":   handler.New(rs.downloadPause),
            "download.resume":  handler.New(rs.downloadResume),
            "download.remove":  handler.New(rs.downloadRemove),
            "download.status":  handler.New(rs.downloadStatus),
            "download.list":    handler.New(rs.downloadList),
        }
    }
    ```

    In download.add handler, set notifier callbacks inline during Handlers struct initialization.
    Do NOT use post-hoc closure wrapping (origHandler pattern). Set the callbacks directly:
    ```go
    // Inside downloadAdd, when building the Handlers struct:
    handlers := &warplib.Handlers{}
    if rs.notifier != nil {
        handlers.DownloadCompleteHandler = func(hash string, tread int64) {
            rs.notifier.Broadcast("download.complete", &DownloadCompleteNotification{
                GID:         hash,
                TotalLength: tread,
            })
        }
        handlers.DownloadProgressHandler = func(hash string, downloaded int64) {
            rs.notifier.Broadcast("download.progress", &DownloadProgressNotification{
                GID:             hash,
                CompletedLength: downloaded,
            })
        }
        handlers.DownloadErrorHandler = func(hash string, err error) {
            rs.notifier.Broadcast("download.error", &DownloadErrorNotification{
                GID:   hash,
                Error: err.Error(),
            })
        }
        handlers.SpawnPartHandler = func(hash string, fileName string, totalSize int64) {
            rs.notifier.Broadcast("download.started", &DownloadStartedNotification{
                GID:         hash,
                FileName:    fileName,
                TotalLength: totalSize,
            })
        }
    }
    ```

    Update NewRPCServer to create notifier:
    ```go
    func NewRPCServer(cfg *RPCConfig, m *warplib.Manager, client *http.Client, pool *Pool, router *warplib.SchemeRouter, l *log.Logger) *RPCServer {
        rs := &RPCServer{
            // ... existing ...
            notifier: NewRPCNotifier(l),
        }
        // ... build methods and bridge ...
    }
    ```

    PHASE F: REFACTOR

    - Ensure wsChannel is minimal (no unnecessary buffering)
    - Verify shutdown sequence: Shutdown -> close bridge -> close listener/notifier
    - go fmt, go vet
    - Race test: go test -race -short ./internal/server/...
  </implementation>
</feature>

<verification>
```bash
cd /Users/divkix/GitHub/warpdl/.claude/worktrees/issues-fix

# Add coder/websocket if needed
go get github.com/coder/websocket@v1.8.14 && go mod tidy

# Notifier unit tests
go test -v -run "TestRPCNotifier" ./internal/server/ -count=1

# WebSocket tests
go test -v -run "TestRPCWebSocket" ./internal/server/ -count=1

# All RPC tests (including 05-01 and 05-02)
go test -v -run "TestRPC" ./internal/server/ -count=1

# Full server package
go test -v ./internal/server/ -count=1

# Full suite -- zero regression
go test ./... -count=1

# Race detection (CRITICAL for notifier concurrency)
go test -race -short ./internal/server/...

# Coverage
go test -cover ./internal/server/...

# Vet
go vet ./...
```
</verification>

<success_criteria>
- RED: Failing tests for WebSocket connect, auth, notifications, notifier lifecycle
- GREEN: All tests pass after implementation
- REFACTOR: Clean code, notifier cleanly separated
- WebSocket upgrade at /jsonrpc/ws works with valid auth
- WebSocket upgrade without auth is rejected
- WebSocket client can call RPC methods (system.getVersion, download.status)
- WebSocket client receives download.started notification
- WebSocket client receives download.progress notification
- WebSocket client receives download.complete notification
- WebSocket client receives download.error notification
- Multiple clients receive same notification
- Disconnected client doesn't block broadcast
- Notifier is thread-safe (passes -race)
- wsChannel adapter correctly bridges coder/websocket to jrpc2.Channel
- No Go 1.25 dependency (wschannel is NOT used -- inlined)
- Existing "/" WebSocket endpoint still works
- bridge.Close() and notifier cleanup in Shutdown()
- All 05-01 and 05-02 tests still pass
- go vet ./... clean
- Coverage >= 80% on internal/server
</success_criteria>

<output>
After completion, create `.planning/phases/05-json-rpc-20/05-03-SUMMARY.md`
</output>
