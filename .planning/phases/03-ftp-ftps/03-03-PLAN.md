---
phase: 03-ftp-ftps
plan: 03
type: tdd
wave: 3
depends_on: [03-01, 03-02]
files_modified:
  - internal/api/api.go
  - internal/api/download.go
  - internal/api/download_ftp_test.go
  - internal/api/resume.go
  - internal/api/api_test.go
  - pkg/warplib/protocol_ftp_test.go
  - cmd/daemon_core.go
autonomous: true
requirements: [FTP-01, FTP-03, FTP-05, FTP-08]

must_haves:
  truths:
    - "API downloadHandler detects ftp:// and ftps:// URLs and dispatches through SchemeRouter instead of NewDownloader (FTP-01)"
    - "API downloadHandler for FTP calls Manager.AddProtocolDownload with credential-stripped URL, ProtoFTP protocol, and correct handlers"
    - "API downloadHandler for FTP returns DownloadResponse with correct ContentLength, DownloadId, FileName, SavePath, MaxConnections=1"
    - "API downloadHandler for FTP starts download via go pd.Download(ctx, handlers) — not go d.Start()"
    - "API downloadHandler for FTPS URLs sets item.Protocol to ProtoFTPS"
    - "API downloadHandler preserves existing HTTP flow completely (zero regression on HTTP URLs)"
    - "API resumeHandler works for FTP items via Manager.ResumeDownload FTP path (delegates to Plan 03-02)"
    - "cmd/daemon_core.go initializes SchemeRouter via NewSchemeRouter(client), calls manager.SetSchemeRouter(router), and passes router to NewApi (SetSchemeRouter is implemented in Plan 03-02)"
    - "All NewApi call sites updated for new signature: cmd/daemon_core.go (production), internal/api/api_test.go (2 test sites at lines ~120 and ~539)"
    - "FTP download with credentials: item.Url persisted to disk does NOT contain credentials (verified via GOB decode)"
    - "FTP download reports file size in DownloadResponse.ContentLength (FTP-08)"
    - "FTP download response has MaxConnections=1 and MaxSegments=1 (FTP-05)"
  artifacts:
    - path: "internal/api/api.go"
      provides: "Updated Api struct with schemeRouter field and NewApi signature accepting *warplib.SchemeRouter"
    - path: "internal/api/download.go"
      provides: "Updated downloadHandler with FTP/FTPS URL detection and SchemeRouter dispatch"
    - path: "internal/api/download_ftp_test.go"
      provides: "Tests for API-level FTP download dispatch, credential stripping verification, response fields"
    - path: "internal/api/resume.go"
      provides: "Updated resumeHandler awareness (mostly unchanged — delegates to Manager.ResumeDownload which handles FTP dispatch per Plan 03-02)"
    - path: "cmd/daemon_core.go"
      provides: "SchemeRouter initialization, Manager.SetSchemeRouter call, and updated NewApi call with router parameter"
    - path: "internal/api/api_test.go"
      provides: "Updated NewApi calls in tests to include SchemeRouter parameter (2 call sites: lines ~120 and ~539)"
  key_links:
    - from: "internal/api/download.go:downloadHandler"
      to: "pkg/warplib/protocol_router.go:SchemeRouter.NewDownloader"
      via: "FTP URL detection triggers SchemeRouter dispatch"
      pattern: "schemeRouter.*NewDownloader"
    - from: "internal/api/download.go:downloadHandler"
      to: "pkg/warplib/manager.go:AddProtocolDownload"
      via: "FTP downloads use AddProtocolDownload instead of AddDownload"
      pattern: "AddProtocolDownload"
    - from: "cmd/daemon_core.go"
      to: "pkg/warplib/protocol_router.go:NewSchemeRouter"
      via: "Daemon core creates SchemeRouter and sets it on Manager, passes to NewApi"
      pattern: "NewSchemeRouter|SetSchemeRouter"
    - from: "cmd/daemon_core.go"
      to: "internal/api/api.go:NewApi"
      via: "Updated NewApi call with SchemeRouter parameter (line ~146)"
      pattern: "api\\.NewApi"
    - from: "internal/api/api_test.go"
      to: "internal/api/api.go:NewApi"
      via: "Test call sites updated for new NewApi signature (2 sites)"
      pattern: "NewApi"
---

<objective>
Wire FTP downloads through the API layer and daemon startup, completing the end-to-end FTP download path from CLI command to file on disk.

Purpose: Plans 03-01 and 03-02 build the FTP downloader and its Manager integration at the warplib level. This plan connects the remaining dots: the API layer's downloadHandler must detect FTP/FTPS URLs, dispatch through SchemeRouter, and use AddProtocolDownload instead of the HTTP-specific AddDownload. The daemon runner must initialize SchemeRouter with all protocol factories. This plan also adds the critical security verification: after a download with credentials, the persisted Item.Url must NOT contain the credentials.

Output: Updated API download handler, daemon SchemeRouter initialization, and integration tests verifying end-to-end FTP flow.
</objective>

<execution_context>
@/Users/divkix/.claude/get-shit-done/workflows/execute-plan.md
@/Users/divkix/.claude/get-shit-done/templates/summary.md
@/Users/divkix/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/03-ftp-ftps/03-RESEARCH.md
@.planning/phases/03-ftp-ftps/03-01-PLAN.md
@.planning/phases/03-ftp-ftps/03-02-PLAN.md

@internal/api/download.go
@internal/api/resume.go
@cmd/daemon_core.go          (actual NewApi call site — daemon initialization)
@internal/api/api_test.go    (NewApi test call sites that must be updated)
@internal/daemon/runner.go   (pure lifecycle manager — does NOT call NewApi, do NOT modify)
@pkg/warplib/protocol_ftp.go    (created by Plan 03-01)
@pkg/warplib/protocol_router.go
@pkg/warplib/manager.go
</context>

<interfaces>
<!-- Key types and contracts the executor needs. -->

From internal/api/download.go — current HTTP-only flow:
```go
func (s *Api) downloadHandler(sconn *server.SyncConn, pool *server.Pool, body json.RawMessage) (common.UpdateType, any, error) {
    // Parses DownloadParams (URL, options)
    // Creates *warplib.Downloader via NewDownloader
    // Builds handlers (ErrorHandler, DownloadProgressHandler, etc.)
    // Calls s.manager.AddDownload(d, opts)
    // Starts: go d.Start()
    // Returns DownloadResponse with ContentLength, DownloadId, FileName, etc.
}
// Must add: if URL scheme is ftp/ftps, use SchemeRouter + AddProtocolDownload path
```

From internal/api/api.go — Api struct (holds references):
```go
type Api struct {
    log      *logger.Logger
    manager  *warplib.Manager
    elEngine *extl.Engine
    client   *http.Client
    // May need: schemeRouter *warplib.SchemeRouter
}
```

From pkg/warplib/manager.go — new methods from Plan 03-01:
```go
func (m *Manager) AddProtocolDownload(pd ProtocolDownloader, probe ProbeResult, cleanURL string, proto Protocol, handlers *Handlers, opts *AddDownloadOpts) error
func (m *Manager) patchProtocolHandlers(h *Handlers, item *Item)
func (m *Manager) SetSchemeRouter(r *SchemeRouter)
```

From pkg/warplib/protocol_ftp.go — factory and downloader (Plan 03-01):
```go
func newFTPProtocolDownloader(rawURL string, opts *DownloaderOpts) (ProtocolDownloader, error)
func (d *ftpProtocolDownloader) Probe(ctx context.Context) (ProbeResult, error)
func (d *ftpProtocolDownloader) Download(ctx context.Context, handlers *Handlers) error
// GetHash(), GetFileName(), GetSavePath(), GetDownloadDirectory(), GetMaxConnections(), GetMaxParts(), GetContentLength()
// cleanURL field — credential-stripped URL
```

From pkg/warplib/protocol.go — Protocol constants:
```go
const (
    ProtoHTTP  Protocol = iota // 0
    ProtoFTP                   // 1
    ProtoFTPS                  // 2
    ProtoSFTP                  // 3
)
```

From common/params.go — DownloadParams (likely):
```go
type DownloadParams struct {
    Url               string  `json:"url"`
    FileName          string  `json:"file_name"`
    DownloadDirectory string  `json:"download_directory"`
    // ... other fields
}
```

From common/response.go — DownloadResponse:
```go
type DownloadResponse struct {
    ContentLength     warplib.ContentLength `json:"content_length"`
    DownloadId        string                `json:"download_id"`
    FileName          string                `json:"file_name"`
    SavePath          string                `json:"save_path"`
    DownloadDirectory string                `json:"download_directory"`
    MaxConnections    int32                 `json:"max_connections"`
    MaxSegments       int32                 `json:"max_segments"`
}
```
</interfaces>

<feature>
  <name>API Layer FTP Integration and Daemon Initialization</name>
  <files>internal/api/api.go, internal/api/download.go, internal/api/download_ftp_test.go, internal/api/resume.go, internal/api/api_test.go, cmd/daemon_core.go, pkg/warplib/protocol_ftp_test.go</files>
  <behavior>
    Test cases for API downloadHandler FTP dispatch:
    1. downloadHandler with ftp://host/file.iso URL creates FTP downloader via SchemeRouter (not NewDownloader)
    2. downloadHandler with ftp://user:pass@host/file.iso URL calls AddProtocolDownload with credential-stripped URL
    3. downloadHandler with ftp:// URL returns DownloadResponse with MaxConnections=1, MaxSegments=1
    4. downloadHandler with ftp:// URL returns DownloadResponse with correct FileName from path.Base
    5. downloadHandler with ftp:// URL returns DownloadResponse with ContentLength from Probe
    6. downloadHandler with ftps:// URL dispatches to FTP factory with useTLS=true
    7. downloadHandler with http:// URL still uses existing NewDownloader path (zero regression)
    8. downloadHandler with https:// URL still uses existing NewDownloader path (zero regression)

    Credential security:
    9. After downloadHandler with ftp://user:pass@host/file, Manager.GetItem(hash).Url does NOT contain "@"
    10. After downloadHandler with ftp://user:pass@host/file, Manager.GetItem(hash).Url does NOT contain "pass"
    11. GOB-encode the Manager, decode, verify persisted Url field still has no credentials

    API resumeHandler FTP:
    12. resumeHandler with FTP item delegates to Manager.ResumeDownload which handles FTP dispatch (per Plan 03-02)
    13. resumeHandler response for FTP item has correct MaxConnections=1

    Daemon initialization (cmd/daemon_core.go, NOT internal/daemon/runner.go which is pure lifecycle):
    14. cmd/daemon_core.go creates SchemeRouter with NewSchemeRouter(client), calls manager.SetSchemeRouter(router), and passes router to api.NewApi
    15. After daemon init, SchemeRouter has http, https, ftp, ftps schemes registered
    15b. All existing NewApi call sites compile after signature change: cmd/daemon_core.go, internal/api/api_test.go (2 sites)

    Error cases:
    16. downloadHandler with ftp://host/ (no file path) returns error from FTP factory (descriptive message)
    17. downloadHandler with ftp:// URL where server is unreachable returns error (transient, from Probe failure)
  </behavior>
  <implementation>
    PHASE A: RED — Write failing tests

    Create internal/api/download_ftp_test.go:
    ```go
    package api

    // Tests use the existing test infrastructure from api package (if available)
    // or create minimal test setup with mock Manager + mock SchemeRouter.
    //
    // For API-level tests that need a real FTP server, use the same
    // fclairamb/ftpserverlib mock from warplib tests.

    func TestDownloadHandlerFTP(t *testing.T) { /* tests 1-6, 16-17 */ }
    func TestDownloadHandlerHTTPRegression(t *testing.T) { /* tests 7-8 */ }
    func TestDownloadHandlerFTPCredentialSecurity(t *testing.T) { /* tests 9-11 */ }
    func TestResumeHandlerFTP(t *testing.T) { /* tests 12-13 */ }
    ```

    Add to pkg/warplib/protocol_ftp_test.go (or new file):
    ```go
    func TestSchemeRouterFTPRegistration(t *testing.T) { /* test 15 */ }
    ```

    NOTE: The API tests may need significant test infrastructure setup. The internal/api package tests currently require SyncConn/Pool/Manager. Evaluate what's available. If the test infrastructure is too heavy, focus on the warplib-level integration tests and do a lighter API test that verifies URL scheme detection logic without full server setup.

    PHASE B: GREEN — Update downloadHandler in internal/api/download.go

    The key change: detect URL scheme before creating the downloader.

    ```go
    func (s *Api) downloadHandler(sconn *server.SyncConn, pool *server.Pool, body json.RawMessage) (common.UpdateType, any, error) {
        var m common.DownloadParams
        if err := json.Unmarshal(body, &m); err != nil {
            return common.UPDATE_DOWNLOAD, nil, err
        }

        // Extract URL (through extension engine)
        url, err := s.elEngine.Extract(m.Url)
        if err != nil {
            s.log.Printf("failed to extract URL from extension: %s\n", err.Error())
            url = m.Url
        }

        // Detect scheme to choose code path
        parsed, parseErr := neturl.Parse(url)
        if parseErr != nil {
            return common.UPDATE_DOWNLOAD, nil, fmt.Errorf("invalid URL: %w", parseErr)
        }
        scheme := strings.ToLower(parsed.Scheme)

        switch scheme {
        case "ftp", "ftps":
            return s.downloadFTPHandler(sconn, pool, url, scheme, &m)
        default:
            // Existing HTTP/HTTPS path — COMPLETELY UNCHANGED
            return s.downloadHTTPHandler(sconn, pool, url, &m)
        }
    }

    // downloadHTTPHandler is the existing HTTP download logic, extracted from downloadHandler.
    // NO changes to logic — only moved into a separate function for clarity.
    func (s *Api) downloadHTTPHandler(sconn *server.SyncConn, pool *server.Pool, url string, m *common.DownloadParams) (common.UpdateType, any, error) {
        // ... EXACT existing code from downloadHandler ...
    }

    // downloadFTPHandler handles FTP and FTPS downloads.
    func (s *Api) downloadFTPHandler(sconn *server.SyncConn, pool *server.Pool, rawURL, scheme string, m *common.DownloadParams) (common.UpdateType, any, error) {
        if s.schemeRouter == nil {
            return common.UPDATE_DOWNLOAD, nil, fmt.Errorf("FTP downloads not available: scheme router not initialized")
        }

        // Create FTP downloader via SchemeRouter
        pd, err := s.schemeRouter.NewDownloader(rawURL, &warplib.DownloaderOpts{
            FileName:          m.FileName,
            DownloadDirectory: m.DownloadDirectory,
        })
        if err != nil {
            return common.UPDATE_DOWNLOAD, nil, err
        }

        // Probe to get file metadata
        probe, err := pd.Probe(context.Background())
        if err != nil {
            pd.Close()
            return common.UPDATE_DOWNLOAD, nil, err
        }

        // Determine protocol
        proto := warplib.ProtoFTP
        if scheme == "ftps" {
            proto = warplib.ProtoFTPS
        }

        // Build handlers (same pattern as HTTP but using pd.GetHash())
        handlers := &warplib.Handlers{
            ErrorHandler: func(_ string, err error) {
                if errors.Is(err, context.Canceled) && pd.IsStopped() {
                    return
                }
                uid := pd.GetHash()
                pool.Broadcast(uid, server.InitError(err))
                pool.WriteError(uid, server.ErrorTypeCritical, err.Error())
                pool.StopDownload(uid)
                s.manager.GetItem(uid).StopDownload()
            },
            DownloadProgressHandler: func(hash string, nread int) {
                uid := pd.GetHash()
                pool.Broadcast(uid, server.MakeResult(common.UPDATE_DOWNLOADING, &common.DownloadingResponse{
                    DownloadId: uid,
                    Action:     common.DownloadProgress,
                    Value:      int64(nread),
                    Hash:       hash,
                }))
            },
            DownloadCompleteHandler: func(hash string, tread int64) {
                uid := pd.GetHash()
                pool.Broadcast(uid, server.MakeResult(common.UPDATE_DOWNLOADING, &common.DownloadingResponse{
                    DownloadId: uid,
                    Action:     common.DownloadComplete,
                    Value:      tread,
                    Hash:       hash,
                }))
            },
            DownloadStoppedHandler: func() {
                uid := pd.GetHash()
                pool.Broadcast(uid, server.MakeResult(common.UPDATE_DOWNLOADING, &common.DownloadingResponse{
                    DownloadId: uid,
                    Action:     common.DownloadStopped,
                }))
            },
            SpawnPartHandler: func(hash string, ioff, foff int64) {
                uid := pd.GetHash()
                pool.Broadcast(uid, server.MakeResult(common.UPDATE_DOWNLOADING, &common.DownloadingResponse{
                    DownloadId: uid,
                    Action:     common.SpawnPart,
                    Hash:       hash,
                }))
            },
        }

        // Get credential-stripped URL for storage
        cleanURL := warplib.StripURLCredentials(rawURL) // or pd.GetCleanURL()

        pool.AddDownload(pd.GetHash(), sconn)
        err = s.manager.AddProtocolDownload(pd, probe, cleanURL, proto, handlers, &warplib.AddDownloadOpts{
            ChildHash:        m.ChildHash,
            IsHidden:         m.IsHidden,
            IsChildren:       m.IsChildren,
            AbsoluteLocation: pd.GetDownloadDirectory(),
            Priority:         warplib.Priority(m.Priority),
        })
        if err != nil {
            return common.UPDATE_DOWNLOAD, nil, err
        }

        // Start FTP download
        go pd.Download(context.Background(), handlers)

        return common.UPDATE_DOWNLOAD, &common.DownloadResponse{
            ContentLength:     pd.GetContentLength(),
            DownloadId:        pd.GetHash(),
            FileName:          pd.GetFileName(),
            SavePath:          pd.GetSavePath(),
            DownloadDirectory: pd.GetDownloadDirectory(),
            MaxConnections:    pd.GetMaxConnections(),
            MaxSegments:       pd.GetMaxParts(),
        }, nil
    }
    ```

    PHASE C: Update Api struct to hold SchemeRouter

    In internal/api/api.go (or wherever Api is defined):
    ```go
    type Api struct {
        log          *logger.Logger
        manager      *warplib.Manager
        elEngine     *extl.Engine
        client       *http.Client
        schemeRouter *warplib.SchemeRouter  // NEW: for FTP/FTPS dispatch
    }
    ```

    Update the Api constructor to accept SchemeRouter:
    ```go
    // NOTE: The actual current signature is:
    //   func NewApi(l *log.Logger, m *warplib.Manager, client *http.Client, elEngine *extl.Engine, version, commit, buildType string) (*Api, error)
    // Updated signature adds router parameter:
    func NewApi(l *log.Logger, m *warplib.Manager, client *http.Client, elEngine *extl.Engine, router *warplib.SchemeRouter, version, commit, buildType string) (*Api, error) {
        return &Api{
            log:          l,
            manager:      m,
            client:       client,
            elEngine:     elEngine,
            schemeRouter: router,
            version:      version,
            commit:       commit,
            buildType:    buildType,
        }, nil
    }
    ```

    PHASE D: Update daemon core to initialize SchemeRouter and fix all NewApi call sites

    PRE-IMPLEMENTATION STEP (MANDATORY): Run `grep -r 'NewApi(' across all packages` to confirm all
    call sites. Known call sites as of planning:
      1. cmd/daemon_core.go:146         — production: api.NewApi(stdLog, m, client, elEng, ...)
      2. internal/api/api_test.go:120   — test: NewApi(log.New(io.Discard, "", 0), m, &http.Client{}, eng, ...)
      3. internal/api/api_test.go:539   — test: NewApi(log.New(io.Discard, "", 0), m, &http.Client{}, eng, ...)
    If grep finds any additional call sites, add them to files_modified and update them.

    In cmd/daemon_core.go (around line 146, where NewApi is called):
    ```go
    // Create SchemeRouter with all protocol factories
    router := warplib.NewSchemeRouter(client) // Already registers http, https, ftp, ftps
    m.SetSchemeRouter(router)
    // Pass router to Api constructor (updated signature)
    s, err := api.NewApi(stdLog, m, client, elEng, router,
        currentBuildArgs.Version, currentBuildArgs.Commit, currentBuildArgs.BuildType)
    ```

    In internal/api/api_test.go (both call sites ~line 120 and ~line 539):
    ```go
    // Tests can pass nil for SchemeRouter when FTP dispatch is not under test
    api, err := NewApi(log.New(io.Discard, "", 0), m, &http.Client{}, eng, nil, "test", "abc123", "test")
    ```

    NOTE: internal/daemon/runner.go is a PURE lifecycle manager (Start/Shutdown/IsRunning).
    It does NOT create Manager, Api, or SchemeRouter. Do NOT modify runner.go.

    PHASE E: REFACTOR

    - Verify HTTP path is extracted cleanly into downloadHTTPHandler with zero logic changes
    - Verify all SpawnPart actions in common package include the FTP action type (if needed)
    - Verify StripURLCredentials is exported from warplib (Plan 03-01 exports it as StripURLCredentials)
    - Run full test suite

    NOTE ON TEST INFRASTRUCTURE: If internal/api tests are difficult to set up (require running server, SyncConn mocking, etc.), focus on:
    1. Unit tests at warplib level (already covered by 03-01 and 03-02)
    2. Simpler API tests that verify the URL scheme detection logic in isolation
    3. Integration test that exercises the full path only if infrastructure allows

    The security-critical test (credential stripping) MUST be present regardless — if API tests are too complex, add it as a warplib-level test that simulates the AddProtocolDownload -> GOB encode -> decode -> verify Url flow.
  </implementation>
</feature>

<verification>
```bash
# Per-task TDD cycle
go test -v -run "TestDownloadHandler" ./internal/api/ -count=1
go test -v -run "TestResumeHandler" ./internal/api/ -count=1
go test -v -run "TestSchemeRouterFTPRegistration" ./pkg/warplib/ -count=1

# All FTP tests across packages
go test -v -run "TestFTP|TestDownloadHandlerFTP|TestResumeHandlerFTP" ./... -count=1

# Regression — ALL existing tests must still pass (especially HTTP download handler)
go test ./internal/api/ -count=1
go test ./pkg/warplib/ -count=1
go test ./... -count=1

# Race detection
go test -race -short ./...

# Coverage check — must remain >= 80% per package
scripts/check_coverage.sh

# Vet
go vet ./...

# Build succeeds (binary compiles)
make build
```
</verification>

<success_criteria>
- RED: Failing tests exist for API FTP dispatch, credential security, daemon init
- GREEN: All tests pass after API update and daemon wiring
- REFACTOR: Clean extraction of HTTP path into downloadHTTPHandler — zero logic change
- API detects ftp:// and ftps:// URLs and dispatches through SchemeRouter
- API returns correct DownloadResponse for FTP (MaxConnections=1, ContentLength from Probe)
- NON-NEGOTIABLE: Credentials in FTP URL are NEVER persisted to Item.Url (security critical — verified by test including GOB encode/decode round-trip). This test MUST exist regardless of API test infrastructure complexity — if API tests are too heavy, implement it at warplib level.
- HTTP download path is completely unchanged (zero regression)
- cmd/daemon_core.go initializes SchemeRouter and wires it to Manager (SetSchemeRouter) and Api (NewApi parameter)
- All NewApi call sites updated for new signature: cmd/daemon_core.go, internal/api/api_test.go (2 sites)
- Binary builds successfully with make build
- All existing tests pass across all packages — zero regression
- go vet ./... clean
- Coverage remains >= 80% per package (enforced by scripts/check_coverage.sh)
</success_criteria>

<output>
After completion, create `.planning/phases/03-ftp-ftps/03-03-SUMMARY.md`
</output>
