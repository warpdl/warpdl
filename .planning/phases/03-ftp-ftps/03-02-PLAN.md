---
phase: 03-ftp-ftps
plan: 02
type: tdd
wave: 2
depends_on: [03-01]
files_modified:
  - pkg/warplib/protocol_ftp.go
  - pkg/warplib/protocol_ftp_test.go
  - pkg/warplib/manager.go
autonomous: true
requirements: [FTP-06, FTP-07]

must_haves:
  truths:
    - "Resume() connects fresh, sets binary mode, calls RetrFrom(path, uint64(offset)) to resume from byte offset (FTP-06)"
    - "Resume() finds the single uncompiled part from parts map, extracts its start offset for RetrFrom"
    - "Resume() opens destination file with O_WRONLY, seeks to offset, streams from RetrFrom response"
    - "Resume() guards against negative offset (returns error instead of uint64 wraparound)"
    - "Resume() calls handlers.DownloadProgressHandler during streaming and handlers.DownloadCompleteHandler(MAIN_HASH, totalBytes) on success"
    - "Resume() with all parts compiled (fully downloaded) returns nil immediately without connecting"
    - "Resume() file operations use WarpOpenFile with DefaultFileMode (NOT os.OpenFile with literal 0644) for Windows cross-platform support"
    - "ftps:// URL causes DialWithExplicitTLS to be used with tls.Config{ServerName: hostname} (FTP-07)"
    - "ftps:// does NOT use DialWithTLS (implicit TLS on port 990) — explicit only via STARTTLS (FTP-07)"
    - "Manager.ResumeDownload skips validateDownloadIntegrity for FTP items (FTP has no segment files); instead checks destination file exists if Downloaded > 0"
    - "Manager.ResumeDownload handles item.Protocol == ProtoFTP by creating FTP downloader via SchemeRouter and calling Resume"
    - "Manager.ResumeDownload handles item.Protocol == ProtoFTPS by creating FTPS downloader via SchemeRouter and calling Resume"
    - "FTP resume integration test: partial download interrupted, resumed from offset, final file matches expected content"
    - "FTPS probe against TLS-enabled mock server succeeds"
    - "User-observable: An interrupted FTP download can be resumed from the CLI and completes to the correct final file without re-downloading already-fetched bytes"
    - "User-observable: FTPS (ftp:// with TLS) URLs are accepted and connect securely without user configuration beyond the URL scheme"
    - "User-observable: Resuming an FTP download that was already fully completed is a no-op (returns immediately)"
  artifacts:
    - path: "pkg/warplib/protocol_ftp.go"
      provides: "Resume method implementation, FTPS TLS dial path (already partially in connect() from 03-01)"
    - path: "pkg/warplib/protocol_ftp_test.go"
      provides: "Resume tests with mock server, FTPS TLS tests, Manager.ResumeDownload FTP path tests"
    - path: "pkg/warplib/manager.go"
      provides: "Updated ResumeDownload to handle non-HTTP protocols via SchemeRouter"
  key_links:
    - from: "pkg/warplib/protocol_ftp.go:Resume"
      to: "github.com/jlaffaye/ftp:ServerConn.RetrFrom"
      via: "RetrFrom(path, uint64(offset)) issues REST before RETR"
      pattern: "RetrFrom"
    - from: "pkg/warplib/manager.go:ResumeDownload"
      to: "pkg/warplib/protocol_ftp.go:ftpProtocolDownloader"
      via: "SchemeRouter creates FTP downloader for resume when item.Protocol != ProtoHTTP"
      pattern: "item\\.Protocol.*ProtoHTTP"
    - from: "pkg/warplib/manager.go:ResumeDownload"
      to: "pkg/warplib/integrity.go:validateDownloadIntegrity"
      via: "EXISTING function — called ONLY for ProtoHTTP items. FTP items skip it (no segment files). DO NOT reimplement."
      pattern: "validateDownloadIntegrity"
---

<objective>
Add FTP resume via RetrFrom offset, FTPS explicit TLS support, and wire Manager.ResumeDownload for non-HTTP protocols.

Purpose: Plan 03-01 delivers fresh FTP downloads. This plan completes the FTP story with resume-after-interruption (FTP-06) and encrypted FTPS transfers (FTP-07). It also wires `Manager.ResumeDownload` to dispatch non-HTTP items through `SchemeRouter` instead of the HTTP-specific `initDownloader` path, making resume work for FTP/FTPS items stored in `userdata.warp`.

Output: Resume() method in protocol_ftp.go, FTPS TLS path verified, Manager.ResumeDownload FTP dispatch, and comprehensive tests.
</objective>

<execution_context>
@/Users/divkix/.claude/get-shit-done/workflows/execute-plan.md
@/Users/divkix/.claude/get-shit-done/templates/summary.md
@/Users/divkix/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/03-ftp-ftps/03-RESEARCH.md
@.planning/phases/03-ftp-ftps/03-01-PLAN.md

@pkg/warplib/protocol_ftp.go      (created by Plan 03-01)
@pkg/warplib/protocol_ftp_test.go  (created by Plan 03-01)
@pkg/warplib/protocol.go
@pkg/warplib/protocol_router.go
@pkg/warplib/manager.go
@pkg/warplib/item.go
@pkg/warplib/handlers.go
</context>

<interfaces>
<!-- Key types and contracts the executor needs. -->

From pkg/warplib/protocol_ftp.go (created by Plan 03-01):
```go
type ftpProtocolDownloader struct {
    rawURL   string
    opts     *DownloaderOpts
    host     string
    ftpPath  string
    user     string
    password string
    useTLS   bool
    fileName string
    fileSize int64
    hash     string
    dlDir    string
    savePath string
    probed   bool
    stopped  int32
    cleanURL string
}

func (d *ftpProtocolDownloader) connect(ctx context.Context) (*ftp.ServerConn, error) {
    // Already handles TLS via d.useTLS — DialWithExplicitTLS path
}

func (d *ftpProtocolDownloader) Resume(ctx context.Context, parts map[int64]*ItemPart, handlers *Handlers) error {
    // STUB from Plan 03-01 — must be implemented here
}
```

From github.com/jlaffaye/ftp v0.2.0:
```go
func (c *ServerConn) RetrFrom(path string, offset uint64) (*Response, error)
// Note: offset is uint64, NOT int64 — guard against negative values
```

From pkg/warplib/manager.go — current ResumeDownload (HTTP-only):
```go
func (m *Manager) ResumeDownload(client *http.Client, hash string, opts *ResumeDownloadOpts) (item *Item, err error) {
    item = m.GetItem(hash)
    // ... validates item exists, is resumable, has integrity ...
    d, er := initDownloader(client, hash, item.Url, item.TotalSize, &DownloaderOpts{...})
    m.patchHandlers(d, item)
    adapter := &httpProtocolDownloader{inner: d, rawURL: item.Url, probed: true}
    item.setDAlloc(adapter)
    m.UpdateItem(item)
    return
}
// Must add: if item.Protocol != ProtoHTTP, use SchemeRouter instead of initDownloader
```

From pkg/warplib/item.go — Resume flow:
```go
func (i *Item) Resume() error {
    // Snapshots Parts, gets dAlloc, calls d.Resume(context.Background(), partsCopy, nil)
    // NOTE: passes nil handlers because patchHandlers/patchProtocolHandlers already installed them
}
```
</interfaces>

<feature>
  <name>FTP Resume and FTPS Explicit TLS</name>
  <files>pkg/warplib/protocol_ftp.go, pkg/warplib/protocol_ftp_test.go, pkg/warplib/manager.go</files>
  <behavior>
    Test cases for FTP-06 (resume via RetrFrom offset):
    1. Resume() with single uncompiled part at offset 512 calls RetrFrom(path, 512) — verified by checking destination file content starts at correct offset
    2. Resume() opens destination file, seeks to offset, writes from RetrFrom response — final file matches expected content
    3. Resume() with negative offset returns descriptive error (guards uint64 wraparound)
    4. Resume() with all parts compiled returns nil without connecting (no-op for complete download)
    5. Resume() without Probe() returns ErrProbeRequired
    6. Resume() calls DownloadProgressHandler during streaming
    7. Resume() calls DownloadCompleteHandler(MAIN_HASH, totalBytes) on success

    Integration: FTP resume end-to-end:
    8. Start fresh FTP download against mock server (1024 bytes)
    9. Interrupt after 512 bytes (simulate by creating partial file + single uncompiled part)
    10. Call Resume with the partial state — file completed from offset 512
    11. Final file content matches full expected content (first 512 bytes original + remaining from server)

    Test cases for FTP-07 (FTPS explicit TLS):
    12. ftpProtocolDownloader with useTLS=true calls DialWithExplicitTLS (not DialWithTLS)
    13. FTPS Probe() succeeds against TLS-enabled mock server (if fclairamb/ftpserverlib supports TLS in test — if not, verify the DialOption selection path via unit test)
    14. tls.Config.ServerName is set to the hostname (not host:port)
    15. SchemeRouter dispatches "ftps://host/file" to FTP factory with useTLS=true

    Manager.ResumeDownload for FTP:
    16. ResumeDownload with item.Protocol==ProtoFTP creates FTP downloader via SchemeRouter, not initDownloader
    17. ResumeDownload with item.Protocol==ProtoFTP calls patchProtocolHandlers (not patchHandlers)
    18. ResumeDownload with item.Protocol==ProtoHTTP still uses initDownloader path with validateDownloadIntegrity (zero regression)
    19. ResumeDownload with item.Protocol==ProtoFTPS creates FTPS downloader via SchemeRouter
    20. After ResumeDownload for FTP item, Item.Resume() works correctly (calls pd.Resume with parts)

    Protocol guard for validateDownloadIntegrity:
    21. ResumeDownload with item.Protocol==ProtoFTP does NOT call validateDownloadIntegrity (no segment dir check)
    22. ResumeDownload with item.Protocol==ProtoFTP and Downloaded>0 but missing destination file returns ErrDownloadDataMissing
    23. ResumeDownload with item.Protocol==ProtoFTP and Downloaded==0 (never started) succeeds without destination file check
    24. ResumeDownload with item.Protocol==ProtoHTTP and missing segment dir returns ErrDownloadDataMissing (existing behavior preserved)
  </behavior>
  <implementation>
    PHASE A: RED — Write failing tests

    Add to pkg/warplib/protocol_ftp_test.go:
    ```go
    func TestFTPResume(t *testing.T) { /* tests 1-7 */ }
    func TestFTPResumeIntegration(t *testing.T) { /* tests 8-11 */ }
    func TestFTPSExplicitTLS(t *testing.T) { /* tests 12-15 */ }
    func TestResumeDownloadFTP(t *testing.T) { /* tests 16-20 */ }
    func TestResumeDownloadFTPIntegrityGuard(t *testing.T) { /* tests 21-24: protocol guard skips validateDownloadIntegrity for FTP */ }
    ```

    For the resume integration test (tests 8-11):
    - Start mock FTP server with a known file (1024 bytes)
    - Manually create a partial file on disk (first 512 bytes of expected content)
    - Construct parts map: { 0: &ItemPart{Hash: "part0", FinalOffset: 1023, Compiled: false} }
    - The offset for resume is the current downloaded size (512), but the parts map key is the initial offset (0) with the part tracking how much was compiled
    - Actually for FTP single-stream: the parts map has one entry: key=0, FinalOffset=fileSize-1. The start offset for RetrFrom is derived from the current file size on disk (or item.Downloaded). The FTP downloader must determine the resume offset from the uncompiled part's start + bytes already written.
    - SIMPLER APPROACH per research: The parts map entry has key=startOffset. For a partially downloaded FTP file, the part at offset 0 is uncompiled. The actual resume byte position is the current size of the destination file. FTP Resume() should use the destination file size as the offset for RetrFrom, not the parts map key (which is always 0 for FTP).
    - CORRECTION: Follow the research pattern. Parts map for FTP will have a single entry. On interruption, the item.Downloaded tracks how much was downloaded. For Resume(), the offset should be derived from item.Downloaded (passed as part of the parts/item state). The simplest approach: ftpProtocolDownloader.Resume takes parts, finds the uncompiled part, and uses the PART'S initial offset + what's been downloaded as the resume byte. But parts don't track per-part downloaded bytes.
    - BEST APPROACH: The resume offset equals the size of the partial file on disk. ftpProtocolDownloader.Resume() checks the file on disk:
      ```go
      info, err := os.Stat(d.savePath)
      startOffset := info.Size() // resume from here
      ```
      This is the most reliable approach for FTP single-stream — the file on disk IS the source of truth for how much was downloaded.

    PHASE B: GREEN — Implement Resume() in protocol_ftp.go

    ```go
    func (d *ftpProtocolDownloader) Resume(ctx context.Context, parts map[int64]*ItemPart, handlers *Handlers) error {
        if !d.probed {
            return ErrProbeRequired
        }

        // Check if all parts are compiled (download complete)
        allCompiled := true
        for _, part := range parts {
            if part != nil && !part.Compiled {
                allCompiled = false
                break
            }
        }
        if allCompiled {
            return nil // Nothing to resume
        }

        // Determine resume offset from destination file size
        var startOffset int64
        info, err := WarpStat(d.savePath)
        if err != nil {
            if os.IsNotExist(err) {
                startOffset = 0 // File doesn't exist — start from beginning
            } else {
                return NewPermanentError("ftp", "resume:stat", err)
            }
        } else {
            startOffset = info.Size()
        }

        // Guard against negative offset (should never happen, but prevent uint64 wraparound)
        if startOffset < 0 {
            return NewPermanentError("ftp", "resume:offset",
                fmt.Errorf("invalid resume offset: %d", startOffset))
        }

        // If offset >= fileSize, download is complete
        if startOffset >= d.fileSize {
            if handlers != nil && handlers.DownloadCompleteHandler != nil {
                handlers.DownloadCompleteHandler(MAIN_HASH, d.fileSize)
            }
            return nil
        }

        conn, err := d.connect(ctx)
        if err != nil {
            return NewTransientError("ftp", "resume:connect", err)
        }
        defer conn.Quit()

        if err := conn.Type(ftp.TransferTypeBinary); err != nil {
            return NewPermanentError("ftp", "resume:type", err)
        }

        // Open file for writing at offset — uses WarpOpenFile for Windows cross-platform support
        // and DefaultFileMode for consistent permissions (NOT literal 0644)
        f, err := WarpOpenFile(d.savePath, os.O_WRONLY|os.O_CREATE, DefaultFileMode)
        if err != nil {
            return NewPermanentError("ftp", "resume:open", err)
        }
        defer f.Close()

        if _, err := f.Seek(startOffset, io.SeekStart); err != nil {
            return NewPermanentError("ftp", "resume:seek", err)
        }

        // RetrFrom issues REST <offset> before RETR
        resp, err := conn.RetrFrom(d.ftpPath, uint64(startOffset))
        if err != nil {
            return classifyFTPError("ftp", "resume:retrfrom", err)
        }
        defer resp.Close()

        // Progress-tracking copy
        pw := &ftpProgressWriter{handlers: handlers, hash: d.hash}
        _, err = io.Copy(io.MultiWriter(f, pw), resp)
        if err != nil {
            return classifyFTPError("ftp", "resume:copy", err)
        }

        if handlers != nil && handlers.DownloadCompleteHandler != nil {
            handlers.DownloadCompleteHandler(MAIN_HASH, d.fileSize)
        }
        return nil
    }
    ```

    PHASE C: Update Manager.ResumeDownload for non-HTTP protocols

    In pkg/warplib/manager.go, modify ResumeDownload:

    ```go
    func (m *Manager) ResumeDownload(client *http.Client, hash string, opts *ResumeDownloadOpts) (item *Item, err error) {
        if opts == nil {
            opts = &ResumeDownloadOpts{}
        }
        item = m.GetItem(hash)
        if item == nil {
            err = ErrDownloadNotFound
            return
        }
        if !item.Resumable {
            err = ErrDownloadNotResumable
            return
        }

        // PROTOCOL GUARD: validateDownloadIntegrity checks for HTTP-specific segment files
        // ({DlDataDir}/{hash}/ directory, .warp part files) that FTP never creates.
        // FTP uses single-stream download to the destination file directly.
        // Only run segment-file integrity checks for HTTP; for FTP, verify the
        // destination file exists (if any bytes were downloaded).
        switch item.Protocol {
        case ProtoHTTP:
            // HTTP: validate segment directory + part files
            if err = validateDownloadIntegrity(item); err != nil {
                return
            }
        case ProtoFTP, ProtoFTPS:
            // FTP: no segment files exist. Only verify destination file if download started.
            if item.Downloaded > 0 {
                mainFile := item.GetAbsolutePath()
                if !fileExists(mainFile) {
                    err = fmt.Errorf("%w: destination file missing for FTP resume: %s", ErrDownloadDataMissing, mainFile)
                    return
                }
            }
        default:
            err = fmt.Errorf("resume not supported for protocol %s", item.Protocol)
            return
        }

        // Dispatch based on protocol
        switch item.Protocol {
        case ProtoHTTP:
            // Existing HTTP resume path — unchanged
            // ... (keep current initDownloader + patchHandlers + adapter code) ...

        case ProtoFTP, ProtoFTPS:
            // FTP/FTPS resume via SchemeRouter
            if m.schemeRouter == nil {
                err = fmt.Errorf("scheme router not initialized")
                return
            }
            // Reconstruct the URL for SchemeRouter dispatch
            // item.Url has credentials stripped, but FTP resume doesn't need credentials
            // (FTP resume of anonymous downloads just works; credential downloads need
            //  the user to re-provide credentials or have them in the URL)
            // For now: use item.Url as-is (no credentials needed for anonymous resume)
            pd, pdErr := m.schemeRouter.NewDownloader(item.Url, &DownloaderOpts{
                FileName:          item.Name,
                DownloadDirectory: item.DownloadLocation,
                Handlers:          opts.Handlers,
            })
            if pdErr != nil {
                err = pdErr
                return
            }
            // Probe to get file metadata (size, etc.)
            _, probeErr := pd.Probe(context.Background())
            if probeErr != nil {
                err = probeErr
                return
            }
            // Patch handlers for item state updates
            if opts.Handlers == nil {
                opts.Handlers = &Handlers{}
            }
            m.patchProtocolHandlers(opts.Handlers, item)
            item.setDAlloc(pd)
            m.UpdateItem(item)

        // default: already handled by protocol guard above (returns early for unknown protocols)
        }
        return
    }
    ```

    NOTE: Manager needs a `schemeRouter *SchemeRouter` field. This may already be added by 03-01 or needs to be added here. The SchemeRouter should be initialized in the daemon startup or passed to the Manager.

    IMPORTANT DESIGN DECISION: The Manager needs access to a SchemeRouter for resume dispatch. Options:
    1. Add `schemeRouter *SchemeRouter` field to Manager, set via `Manager.SetSchemeRouter(r)` after init
    2. Pass SchemeRouter into ResumeDownload as parameter
    3. Use a package-level default router

    RECOMMENDED: Option 1 — add field + setter. The daemon startup creates the SchemeRouter and sets it on the Manager. This is consistent with how the HTTP client is passed into ResumeDownload today. The setter approach allows the Manager to be initialized before the SchemeRouter is configured.

    ```go
    // In Manager struct:
    schemeRouter *SchemeRouter

    // SetSchemeRouter sets the scheme router for protocol dispatch during resume.
    func (m *Manager) SetSchemeRouter(r *SchemeRouter) {
        m.schemeRouter = r
    }
    ```

    PHASE D: REFACTOR — Clean up

    - Ensure Resume path for HTTP is completely unchanged (zero regression)
    - Verify ResumeDownload test coverage for both HTTP and FTP paths
    - Run full test suite
  </implementation>
</feature>

<verification>
```bash
# Per-task TDD cycle
go test -v -run "TestFTPResume$" ./pkg/warplib/ -count=1
go test -v -run "TestFTPResumeIntegration" ./pkg/warplib/ -count=1
go test -v -run "TestFTPSExplicitTLS" ./pkg/warplib/ -count=1
go test -v -run "TestResumeDownloadFTP$" ./pkg/warplib/ -count=1
go test -v -run "TestResumeDownloadFTPIntegrityGuard" ./pkg/warplib/ -count=1

# All FTP tests
go test -v -run "TestFTP" ./pkg/warplib/ -count=1

# Regression — ALL existing tests must still pass (especially HTTP resume)
go test ./pkg/warplib/ -count=1

# Full suite including internal packages
go test ./... -count=1

# Race detection
go test -race -short ./pkg/warplib/

# Coverage check — must remain >= 80%
go test -cover ./pkg/warplib/

# Vet
go vet ./...
```
</verification>

<success_criteria>
- RED: Failing tests exist for FTP resume, FTPS TLS, Manager.ResumeDownload FTP path
- GREEN: All tests pass after Resume implementation and Manager update
- REFACTOR: Clean code, no duplication between HTTP and FTP resume paths in Manager
- Resume() uses RetrFrom with correct uint64 offset derived from destination file size
- Resume() guards against negative offset
- Resume() handles all-compiled parts (no-op) and missing file (start from zero)
- FTPS uses DialWithExplicitTLS (not DialWithTLS) with correct ServerName
- Manager.ResumeDownload dispatches FTP/FTPS items through SchemeRouter
- Manager.ResumeDownload skips validateDownloadIntegrity for FTP (protocol guard before integrity check)
- Manager.ResumeDownload for FTP with Downloaded>0 verifies destination file exists
- Manager.ResumeDownload HTTP path is completely unchanged (zero regression, still calls validateDownloadIntegrity)
- Full resume integration: partial file -> resume -> correct final file
- All existing tests pass (pkg/warplib, internal, cmd) — zero regression
- go vet ./... clean
- Coverage remains >= 80% on pkg/warplib
</success_criteria>

<output>
After completion, create `.planning/phases/03-ftp-ftps/03-02-SUMMARY.md`
</output>
