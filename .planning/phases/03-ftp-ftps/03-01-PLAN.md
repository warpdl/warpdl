---
phase: 03-ftp-ftps
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - pkg/warplib/protocol_ftp.go
  - pkg/warplib/protocol_ftp_test.go
  - pkg/warplib/protocol_router.go
  - pkg/warplib/manager.go
  - go.mod
  - go.sum
autonomous: true
requirements: [FTP-01, FTP-02, FTP-03, FTP-04, FTP-05, FTP-08]

must_haves:
  truths:
    - "ftpProtocolDownloader struct exists in protocol_ftp.go and satisfies ProtocolDownloader interface — compile-time check via var _ ProtocolDownloader = (*ftpProtocolDownloader)(nil)"
    - "newFTPProtocolDownloader factory parses ftp:// and ftps:// URLs, extracting host:port, path, credentials, and TLS flag"
    - "When no credentials in URL, factory defaults to user='anonymous' password='anonymous' (FTP-02)"
    - "When credentials present in URL (ftp://user:pass@host/path), factory extracts username and password correctly (FTP-03)"
    - "Capabilities() returns {SupportsParallel: false, SupportsResume: true} (FTP-05)"
    - "Probe() connects to FTP server, authenticates, calls FileSize for content length, then disconnects (FTP-08)"
    - "Probe() returns ProbeResult with correct FileName (from path.Base), ContentLength (from SIZE), Resumable=true, Checksums=nil"
    - "Download() connects fresh (does not reuse Probe connection), sets binary transfer mode, calls Retr, streams via io.Copy with progress writer"
    - "Download() calls handlers.SpawnPartHandler with single-part range [0, fileSize-1] (FTP-05 single stream) — nil-guarded: if handlers == nil or handlers.SpawnPartHandler == nil, skip the call"
    - "Download() calls handlers.DownloadCompleteHandler(MAIN_HASH, totalBytes) on success (FTP-05, required for Manager completion detection) — nil-guarded: if handlers == nil or handlers.DownloadCompleteHandler == nil, skip the call"
    - "Download() calls handlers.DownloadProgressHandler on each Write from ftpProgressWriter — nil-guarded: ftpProgressWriter checks handlers != nil && handlers.DownloadProgressHandler != nil before calling"
    - "classifyFTPError correctly classifies textproto.Error 4xx as transient, 5xx as permanent, net.Error as transient"
    - "stripURLCredentials removes userinfo from URL: ftp://user:pass@host/path -> ftp://host/path (security critical)"
    - "SchemeRouter has 'ftp' and 'ftps' factories registered after NewSchemeRouter — SupportedSchemes includes both"
    - "Manager.AddProtocolDownload creates Item with correct metadata, sets item.Protocol, calls setDAlloc, and persists"
    - "Manager.patchProtocolHandlers wraps *Handlers with item-update callbacks (Downloaded counter, part tracking, DownloadCompleteHandler MAIN_HASH gate, queue notification)"
    - "Default FTP port is 21 when not specified in URL"
    - "Factory rejects URLs with empty/root path (ftp://host/ or ftp://host) with descriptive error"
    - "FTP passive mode (EPSV) is used by default — no active mode (FTP-04)"
    - "go.mod includes github.com/jlaffaye/ftp v0.2.0 and test dependency fclairamb/ftpserverlib"
  artifacts:
    - path: "pkg/warplib/protocol_ftp.go"
      provides: "ftpProtocolDownloader struct, newFTPProtocolDownloader factory, Probe/Download methods, connect helper, classifyFTPError, stripURLCredentials, ftpProgressWriter"
      exports: ["newFTPProtocolDownloader", "stripURLCredentials"]
    - path: "pkg/warplib/protocol_ftp_test.go"
      provides: "Unit and integration tests using fclairamb/ftpserverlib mock server — factory, auth, capabilities, probe, download, error classification, credential stripping, scheme routing"
    - path: "pkg/warplib/protocol_router.go"
      provides: "Updated NewSchemeRouter with ftp/ftps factory registration"
    - path: "pkg/warplib/manager.go"
      provides: "AddProtocolDownload method, patchProtocolHandlers function"
  key_links:
    - from: "pkg/warplib/protocol_ftp.go:ftpProtocolDownloader"
      to: "pkg/warplib/protocol.go:ProtocolDownloader"
      via: "Interface implementation"
      pattern: "var _ ProtocolDownloader = \\(\\*ftpProtocolDownloader\\)"
    - from: "pkg/warplib/protocol_router.go:NewSchemeRouter"
      to: "pkg/warplib/protocol_ftp.go:newFTPProtocolDownloader"
      via: "ftp/ftps factories registered in SchemeRouter"
      pattern: "routes\\[\"ftp\"\\]"
    - from: "pkg/warplib/manager.go:AddProtocolDownload"
      to: "pkg/warplib/manager.go:patchProtocolHandlers"
      via: "AddProtocolDownload calls patchProtocolHandlers to wrap handlers before storing downloader"
      pattern: "patchProtocolHandlers"
---

<objective>
Implement the core FTP downloader struct with single-stream download, anonymous and credential auth, passive mode, file size probing, and wire it into SchemeRouter and Manager.

Purpose: This is the foundational FTP plan. It creates `ftpProtocolDownloader` implementing `ProtocolDownloader`, registers it in `SchemeRouter` for both `ftp://` and `ftps://` schemes, and adds `Manager.AddProtocolDownload` so the API layer can dispatch FTP downloads. Credential stripping ensures `ftp://user:pass@host/path` never persists credentials to `~/.config/warpdl/userdata.warp`. The mock FTP server (`fclairamb/ftpserverlib`) provides realistic test coverage without network dependencies.

Output: protocol_ftp.go (downloader implementation), protocol_ftp_test.go (comprehensive tests), updated protocol_router.go and manager.go.
</objective>

<execution_context>
@/Users/divkix/.claude/get-shit-done/workflows/execute-plan.md
@/Users/divkix/.claude/get-shit-done/templates/summary.md
@/Users/divkix/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/03-ftp-ftps/03-RESEARCH.md

@pkg/warplib/protocol.go
@pkg/warplib/protocol_http.go
@pkg/warplib/protocol_router.go
@pkg/warplib/manager.go
@pkg/warplib/item.go
@pkg/warplib/handlers.go
@pkg/warplib/errors.go
@pkg/warplib/dloader.go
@internal/api/download.go
</context>

<interfaces>
<!-- Key types and contracts the executor needs. -->

From pkg/warplib/protocol.go — interface the FTP downloader must implement:
```go
type ProtocolDownloader interface {
    Probe(ctx context.Context) (ProbeResult, error)
    Download(ctx context.Context, handlers *Handlers) error
    Resume(ctx context.Context, parts map[int64]*ItemPart, handlers *Handlers) error
    Capabilities() DownloadCapabilities
    Close() error
    Stop()
    IsStopped() bool
    GetMaxConnections() int32
    GetMaxParts() int32
    GetHash() string
    GetFileName() string
    GetDownloadDirectory() string
    GetSavePath() string
    GetContentLength() ContentLength
}

type DownloadCapabilities struct {
    SupportsParallel bool
    SupportsResume   bool
}

type ProbeResult struct {
    FileName      string
    ContentLength int64
    Resumable     bool
    Checksums     []ExpectedChecksum
}

type DownloaderFactory func(rawURL string, opts *DownloaderOpts) (ProtocolDownloader, error)
```

From pkg/warplib/protocol_router.go — registration point:
```go
type SchemeRouter struct {
    routes map[string]DownloaderFactory
}
func NewSchemeRouter(client *http.Client) *SchemeRouter  // add ftp/ftps here
func (r *SchemeRouter) Register(scheme string, factory DownloaderFactory)
```

From pkg/warplib/manager.go — existing AddDownload pattern:
```go
func (m *Manager) AddDownload(d *Downloader, opts *AddDownloadOpts) error {
    item, err := newItem(m.mu, d.fileName, d.url, d.dlLoc, d.hash, d.contentLength, d.resumable, &itemOpts{...})
    m.patchHandlers(d, item)
    adapter := &httpProtocolDownloader{inner: d, ...}
    item.setDAlloc(adapter)
    m.UpdateItem(item)
    if m.queue != nil { m.queue.Add(d.hash, opts.Priority) }
    return nil
}
// New AddProtocolDownload follows same pattern but takes ProtocolDownloader directly
```

From pkg/warplib/manager.go — patchHandlers wrapping pattern (must be replicated):
```go
func (m *Manager) patchHandlers(d *Downloader, item *Item) {
    // Wraps SpawnPartHandler: item.addPart + m.UpdateItem + original
    // Wraps RespawnPartHandler: item.addPart + m.UpdateItem + original
    // Wraps DownloadProgressHandler: item.Downloaded += nread + m.UpdateItem + original
    // Wraps CompileCompleteHandler: part.Compiled=true + item.savePart + original
    // Wraps DownloadCompleteHandler: only fires on MAIN_HASH; clears item.Parts, sets Downloaded=TotalSize, queue.OnComplete, original
}
```

From pkg/warplib/handlers.go — key handler types FTP must invoke:
```go
type Handlers struct {
    SpawnPartHandler        SpawnPartHandlerFunc        // (hash, ioff, foff)
    DownloadProgressHandler DownloadProgressHandlerFunc // (hash, nread)
    DownloadCompleteHandler DownloadCompleteHandlerFunc // (hash, tread)
    ErrorHandler            ErrorHandlerFunc            // (hash, err)
    DownloadStoppedHandler  DownloadStoppedHandlerFunc  // ()
    // FTP does NOT use: RespawnPartHandler, CompileStartHandler, CompileProgressHandler, CompileCompleteHandler, WorkStealHandler
    // (those are HTTP multi-part specific)
}
```

From github.com/jlaffaye/ftp v0.2.0 — library API:
```go
func Dial(addr string, options ...DialOption) (*ServerConn, error)
func DialWithContext(ctx context.Context) DialOption
func DialWithTimeout(timeout time.Duration) DialOption
func DialWithExplicitTLS(tlsConfig *tls.Config) DialOption
func (c *ServerConn) Login(user, password string) error
func (c *ServerConn) FileSize(name string) (int64, error)
func (c *ServerConn) Type(transferType TransferType) error
func (c *ServerConn) Retr(path string) (*Response, error)
func (c *ServerConn) RetrFrom(path string, offset uint64) (*Response, error)
func (c *ServerConn) Quit() error
const TransferTypeBinary TransferType
// Response implements io.ReadCloser
```

From net/textproto — FTP error type:
```go
type Error struct {
    Code int
    Msg  string
}
```
</interfaces>

<feature>
  <name>FTP Protocol Downloader with Fresh Download Support</name>
  <files>pkg/warplib/protocol_ftp.go, pkg/warplib/protocol_ftp_test.go, pkg/warplib/protocol_router.go, pkg/warplib/manager.go, go.mod, go.sum</files>
  <behavior>
    Test cases for FTP-01 (download from ftp:// URLs):
    1. newFTPProtocolDownloader("ftp://localhost:2121/pub/file.iso", opts) creates downloader with correct host, path, fileName
    2. SchemeRouter.NewDownloader("ftp://localhost:2121/pub/file.iso", opts) dispatches to FTP factory — returned downloader is *ftpProtocolDownloader
    3. Full download against mock FTP server: file written to disk, bytes match expected content

    Test cases for FTP-02 (anonymous login):
    4. newFTPProtocolDownloader("ftp://host/file") with no userinfo sets user="anonymous", password="anonymous"
    5. Probe() against mock server succeeds with anonymous credentials (mock server accepts anonymous/anonymous)

    Test cases for FTP-03 (credential auth):
    6. newFTPProtocolDownloader("ftp://testuser:testpass@host/file") extracts user="testuser", password="testpass"
    7. Probe() against mock server succeeds with credential auth (mock server requires testuser/testpass for non-anonymous)
    8. stripURLCredentials("ftp://user:pass@host:21/path/file.iso") returns "ftp://host:21/path/file.iso"
    9. stripURLCredentials("ftp://host/path") returns "ftp://host/path" (no-op when no credentials)

    Test cases for FTP-04 (passive mode):
    10. jlaffaye/ftp defaults to EPSV — no explicit configuration needed. Verified by successful Probe/Download against mock server (which uses passive mode).

    Test cases for FTP-05 (single stream):
    11. Capabilities() returns {SupportsParallel: false, SupportsResume: true}
    12. Download calls SpawnPartHandler exactly once with range [0, fileSize-1]
    13. GetMaxConnections() returns 1
    14. GetMaxParts() returns 1

    Test cases for FTP-08 (file size before download):
    15. Probe() returns ProbeResult.ContentLength matching actual file size on mock server
    16. Probe() returns ProbeResult.FileName from path.Base of URL path
    17. Probe() returns Resumable=true, Checksums=nil

    Error classification:
    18. classifyFTPError with textproto.Error{Code: 421} returns transient error
    19. classifyFTPError with textproto.Error{Code: 530} returns permanent error
    20. classifyFTPError with net.OpError returns transient error
    21. classifyFTPError with nil returns nil

    Factory edge cases:
    22. newFTPProtocolDownloader("ftp://host/") returns error (empty filename from root path)
    23. newFTPProtocolDownloader("ftp://host") returns error (no path)
    24. newFTPProtocolDownloader("ftp://host:2121/file.iso") uses port 2121
    25. newFTPProtocolDownloader("ftp://host/file.iso") defaults to port 21
    26. Calling Download() without Probe() returns ErrProbeRequired
    27. Calling Resume() without Probe() returns ErrProbeRequired

    Manager integration:
    28. Manager.AddProtocolDownload creates Item with correct Hash, Name, Url (credential-stripped), TotalSize, Protocol, Resumable
    29. After AddProtocolDownload, item.Url does NOT contain "@" or any password (credential stripping verified)
    30. After AddProtocolDownload, item.Protocol == ProtoFTP for ftp:// URL
    31. patchProtocolHandlers wraps DownloadProgressHandler to update item.Downloaded
    32. patchProtocolHandlers wraps DownloadCompleteHandler to clear item.Parts and set Downloaded=TotalSize on MAIN_HASH
    33. patchProtocolHandlers wraps SpawnPartHandler to call item.addPart

    Nil-handler safety:
    34. Download() with nil *Handlers does not panic — completes download, file written correctly
    35. Download() with partial *Handlers (only DownloadProgressHandler set, others nil) does not panic

    SchemeRouter:
    36. SupportedSchemes includes "ftp" and "ftps" after NewSchemeRouter
    37. SchemeRouter dispatches "FTP://" (uppercase) correctly via case normalization
  </behavior>
  <implementation>
    PHASE A: Add dependencies (go.mod)

    1. Run: cd /Users/divkix/GitHub/warpdl/.claude/worktrees/issues-fix && go get github.com/jlaffaye/ftp@v0.2.0
    2. For tests only: go get github.com/fclairamb/ftpserverlib (test dependency, only in _test.go files)
    3. Run: go mod tidy

    PHASE B: RED — Write failing tests (protocol_ftp_test.go)

    NOTE ON SCOPE: This plan has 37 test cases across a single cohesive feature (FTP downloader).
    Write tests in batches by test function, not all at once. Implement each batch through
    RED->GREEN before moving to the next. Suggested order:
    Batch 1: Factory + Auth + Capabilities (tests 1, 4, 6, 8-9, 11, 22-27) — no mock server needed for most
    Batch 2: Probe + Download + Progress (tests 3, 5, 7, 12-17, 34-35) — mock server required
    Batch 3: Error classification + SchemeRouter + Manager (tests 18-21, 28-33, 36-37)

    Write all test cases listed in behavior section above. Tests use a helper function `startMockFTPServer(t *testing.T) (addr string, cleanup func())` that starts fclairamb/ftpserverlib with afero.NewMemMapFs backend, pre-populated with test files. The mock server accepts:
    - Anonymous: user="anonymous", pass="anonymous"
    - Authenticated: user="testuser", pass="testpass"

    The mock server helper creates test files:
    - /pub/testfile.bin (1024 bytes of known content, e.g., bytes.Repeat([]byte{0xAB}, 1024))
    - /pub/largefile.bin (65536 bytes for progress tracking tests)

    Test structure:
    ```go
    func TestFTPFactory(t *testing.T) { /* tests 1, 22-26 */ }
    func TestFTPAnonymousLogin(t *testing.T) { /* tests 4, 5 */ }
    func TestFTPCredentialAuth(t *testing.T) { /* tests 6, 7 */ }
    func TestStripURLCredentials(t *testing.T) { /* tests 8, 9 */ }
    func TestFTPCapabilities(t *testing.T) { /* test 11 */ }
    func TestFTPProbe(t *testing.T) { /* tests 15, 16, 17 */ }
    func TestFTPDownloadIntegration(t *testing.T) { /* tests 3, 12, 13, 14 */ }
    func TestFTPProgressTracking(t *testing.T) { /* verifies progress handler called */ }
    func TestClassifyFTPError(t *testing.T) { /* tests 18-21 */ }
    func TestFTPNilHandlerSafety(t *testing.T) { /* tests 34, 35 — nil and partial handlers don't panic */ }
    func TestFTPSchemeRouting(t *testing.T) { /* tests 2, 36, 37 */ }
    func TestFTPProbeRequired(t *testing.T) { /* tests 26, 27 */ }
    func TestAddProtocolDownload(t *testing.T) { /* tests 28-33 */ }
    ```

    PHASE C: GREEN — Implement ftpProtocolDownloader (protocol_ftp.go)

    Create pkg/warplib/protocol_ftp.go:

    ```go
    package warplib

    import (
        "context"
        "crypto/rand"
        "crypto/tls"
        "encoding/hex"
        "errors"
        "fmt"
        "io"
        "net"
        "net/textproto"
        "net/url"
        "os"
        "path"
        "strings"
        "sync/atomic"
        "time"

        "github.com/jlaffaye/ftp"
    )

    var _ ProtocolDownloader = (*ftpProtocolDownloader)(nil)

    type ftpProtocolDownloader struct {
        rawURL   string
        opts     *DownloaderOpts
        host     string    // host:port
        ftpPath  string    // file path on server
        user     string    // from URL userinfo — NOT persisted
        password string    // from URL userinfo — NOT persisted
        useTLS   bool      // true for ftps://
        fileName string    // path.Base of URL path
        fileSize int64     // set during Probe
        hash     string    // unique download ID
        dlDir    string    // download directory
        savePath string    // full save path
        probed   bool
        stopped  int32     // atomic
        cleanURL string    // URL with credentials stripped — safe to persist
    }
    ```

    Key methods:
    - `newFTPProtocolDownloader(rawURL string, opts *DownloaderOpts) (ProtocolDownloader, error)` — parse URL, extract credentials, validate path, generate hash, set defaults
    - `connect(ctx context.Context) (*ftp.ServerConn, error)` — Dial with timeout + optional TLS, Login
    - `Probe(ctx context.Context) (ProbeResult, error)` — connect, FileSize, disconnect
    - `Download(ctx context.Context, handlers *Handlers) error` — connect, Type(binary), Retr, io.Copy with progress writer. ALL handler calls must be nil-guarded: check `handlers != nil && handlers.XxxHandler != nil` before calling. This prevents panics when callers provide nil or partial Handlers structs.
    - `Resume(ctx, parts, handlers)` — stub for Plan 03-02 (returns error "not yet implemented" initially, or implement fully here if time permits)
    - `Capabilities()` — returns {false, true}
    - `Close()`, `Stop()`, `IsStopped()` — standard lifecycle
    - `GetMaxConnections()` returns 1, `GetMaxParts()` returns 1
    - `GetHash()`, `GetFileName()`, `GetDownloadDirectory()`, `GetSavePath()`, `GetContentLength()` — getters

    Helper types:
    - `ftpProgressWriter` — implements io.Writer, calls DownloadProgressHandler on each Write
    - `classifyFTPError(proto, op string, err error) *DownloadError` — RFC 959 4xx/5xx classification
    - `stripURLCredentials(rawURL string) (string, error)` — removes userinfo from URL

    PHASE D: Update SchemeRouter (protocol_router.go)

    In NewSchemeRouter, after http/https registration, add:
    ```go
    ftpFactory := func(rawURL string, opts *DownloaderOpts) (ProtocolDownloader, error) {
        return newFTPProtocolDownloader(rawURL, opts)
    }
    r.routes["ftp"] = ftpFactory
    r.routes["ftps"] = ftpFactory
    ```

    PHASE E: Add Manager.AddProtocolDownload and patchProtocolHandlers (manager.go)

    ```go
    // AddProtocolDownload adds a new download item for a non-HTTP protocol downloader.
    // cleanURL is the URL with credentials stripped — safe for GOB persistence.
    // proto identifies the protocol (ProtoFTP, ProtoFTPS, ProtoSFTP).
    func (m *Manager) AddProtocolDownload(pd ProtocolDownloader, probe ProbeResult, cleanURL string, proto Protocol, handlers *Handlers, opts *AddDownloadOpts) error {
        if opts == nil {
            opts = &AddDownloadOpts{}
        }
        item, err := newItem(
            m.mu,
            pd.GetFileName(),
            cleanURL,  // credential-stripped URL — safe to persist
            pd.GetDownloadDirectory(),
            pd.GetHash(),
            ContentLength(probe.ContentLength),
            probe.Resumable,
            &itemOpts{
                AbsoluteLocation: opts.AbsoluteLocation,
                Child:            opts.IsChildren,
                Hide:             opts.IsHidden,
                ChildHash:        opts.ChildHash,
            },
        )
        if err != nil {
            return err
        }
        item.Protocol = proto

        // Wrap handlers with item-update callbacks
        m.patchProtocolHandlers(handlers, item)

        item.setDAlloc(pd)
        m.UpdateItem(item)

        if m.queue != nil {
            m.queue.Add(pd.GetHash(), opts.Priority)
        }
        return nil
    }

    // patchProtocolHandlers wraps handler callbacks to update Item state.
    // This is the protocol-agnostic equivalent of patchHandlers for non-HTTP downloaders.
    // The wrapped handlers are mutated in-place (same as patchHandlers pattern).
    func (m *Manager) patchProtocolHandlers(h *Handlers, item *Item) {
        if h == nil {
            return
        }
        oSPH := h.SpawnPartHandler
        h.SpawnPartHandler = func(hash string, ioff, foff int64) {
            item.addPart(hash, ioff, foff)
            m.UpdateItem(item)
            if oSPH != nil {
                oSPH(hash, ioff, foff)
            }
        }
        oRPH := h.RespawnPartHandler
        h.RespawnPartHandler = func(hash string, partIoff, ioffNew, foffNew int64) {
            item.addPart(hash, partIoff, foffNew)
            m.UpdateItem(item)
            if oRPH != nil {
                oRPH(hash, partIoff, ioffNew, foffNew)
            }
        }
        oPH := h.DownloadProgressHandler
        h.DownloadProgressHandler = func(hash string, nread int) {
            item.mu.Lock()
            item.Downloaded += ContentLength(nread)
            item.mu.Unlock()
            m.UpdateItem(item)
            if oPH != nil {
                oPH(hash, nread)
            }
        }
        oCCH := h.CompileCompleteHandler
        h.CompileCompleteHandler = func(hash string, tread int64) {
            off, part, err := item.getPartWithError(hash)
            if err != nil {
                if h.ErrorHandler != nil {
                    h.ErrorHandler(hash, fmt.Errorf("compile complete: %w", err))
                }
                return
            }
            if part == nil {
                if h.ErrorHandler != nil {
                    h.ErrorHandler(hash, fmt.Errorf("compile complete: part not found for hash %q", hash))
                }
                return
            }
            part.Compiled = true
            item.savePart(off, part)
            if oCCH != nil {
                oCCH(hash, tread)
            }
        }
        oDCH := h.DownloadCompleteHandler
        h.DownloadCompleteHandler = func(hash string, tread int64) {
            if hash != MAIN_HASH {
                return
            }
            item.mu.Lock()
            item.Parts = nil
            item.Downloaded = item.TotalSize
            item.mu.Unlock()
            m.UpdateItem(item)
            if m.queue != nil {
                m.queue.OnComplete(item.Hash)
            }
            if oDCH != nil {
                oDCH(hash, tread)
            }
        }
    }
    ```

    PHASE F: REFACTOR — Ensure clean separation, remove duplication

    After GREEN:
    - Verify patchProtocolHandlers does not duplicate patchHandlers logic unnecessarily. The two functions are intentionally separate: patchHandlers operates on *Downloader (accesses d.handlers directly), patchProtocolHandlers operates on *Handlers (passed in). Do NOT merge them yet — merging would risk HTTP regression. A future refactor (post-Phase 3) could unify them.
    - Ensure all exports are minimal (only what's needed outside the package).
    - Run go vet, go fmt.
  </implementation>
</feature>

<verification>
```bash
# Install dependency
cd /Users/divkix/GitHub/warpdl/.claude/worktrees/issues-fix && go get github.com/jlaffaye/ftp@v0.2.0 && go mod tidy

# Per-task TDD cycle
go test -v -run "TestFTPFactory|TestFTPAnonymousLogin|TestFTPCredentialAuth|TestStripURLCredentials" ./pkg/warplib/ -count=1
go test -v -run "TestFTPCapabilities|TestFTPProbe|TestFTPProbeRequired" ./pkg/warplib/ -count=1
go test -v -run "TestFTPDownloadIntegration|TestFTPProgressTracking" ./pkg/warplib/ -count=1
go test -v -run "TestClassifyFTPError" ./pkg/warplib/ -count=1
go test -v -run "TestFTPSchemeRouting" ./pkg/warplib/ -count=1
go test -v -run "TestAddProtocolDownload" ./pkg/warplib/ -count=1

# Regression — ALL existing tests must still pass
go test ./pkg/warplib/ -count=1

# Full suite including internal packages
go test ./... -count=1

# Race detection
go test -race -short ./pkg/warplib/

# Coverage check — must remain >= 80%
go test -cover ./pkg/warplib/

# Vet
go vet ./...
```
</verification>

<success_criteria>
- RED: Failing tests exist for FTP factory, auth, capabilities, probe, download, error classification, credential stripping, scheme routing, manager integration
- GREEN: All tests pass after ftpProtocolDownloader implementation
- REFACTOR: Clean code, no unnecessary exports, proper error wrapping
- ftpProtocolDownloader satisfies ProtocolDownloader (compile-time check)
- Anonymous FTP works (user=anonymous, password=anonymous)
- Credential auth works (extracted from URL userinfo)
- Credentials are NEVER stored in Item.Url — stripped before persistence
- Download() with nil or partial *Handlers does not panic (nil-guard all handler calls)
- Single-stream download completes with correct file content
- Probe returns accurate file size and filename
- FTP errors classified correctly (4xx transient, 5xx permanent)
- SchemeRouter dispatches ftp:// and ftps:// to FTP factory
- Manager.AddProtocolDownload creates correct Item with Protocol field set
- patchProtocolHandlers wraps handlers to update Item state (Downloaded, Parts, completion)
- All existing tests pass (pkg/warplib, internal, cmd) — zero regression
- go vet ./... clean
- Coverage remains >= 80% on pkg/warplib
</success_criteria>

<output>
After completion, create `.planning/phases/03-ftp-ftps/03-01-SUMMARY.md`
</output>
