---
phase: 02-protocol-interface
plan: 02
type: tdd
wave: 2
depends_on: [02-01]
files_modified:
  - pkg/warplib/item.go
  - pkg/warplib/protocol.go
  - pkg/warplib/protocol_gob_test.go
  - pkg/warplib/testdata/pre_phase2_userdata.warp
  - pkg/warplib/testdata/generate_fixture_test.go
autonomous: true
requirements: [PROTO-03]

must_haves:
  truths:
    - "Protocol type (uint8 with iota) is defined: ProtoHTTP=0, ProtoFTP=1, ProtoFTPS=2, ProtoSFTP=3"
    - "Item struct has Protocol field — zero value defaults to ProtoHTTP"
    - "Pre-Phase-2 GOB fixture (binary file without Protocol field) decodes correctly with Protocol==ProtoHTTP for all items"
    - "Round-trip encode/decode of Item with ProtoHTTP preserves Protocol==ProtoHTTP"
    - "Round-trip encode/decode of Item with ProtoFTP preserves Protocol==ProtoFTP"
    - "Unknown Protocol value (e.g., 7) decoded from GOB does not panic — it decodes as uint8(7)"
    - "Protocol.String() returns human-readable names: http, ftp, ftps, sftp, unknown(N)"
    - "Existing GOB persistence (Manager.persistItems, InitManager decode) works unchanged with the new field"
  artifacts:
    - path: "pkg/warplib/item.go"
      provides: "Protocol type with iota constants, Protocol field on Item struct, String() method"
      exports: ["Protocol", "ProtoHTTP", "ProtoFTP", "ProtoFTPS", "ProtoSFTP"]
    - path: "pkg/warplib/protocol.go"
      provides: "Protocol type definition (may be here instead of item.go for cohesion)"
    - path: "pkg/warplib/protocol_gob_test.go"
      provides: "GOB backward compat golden fixture test, round-trip tests, unknown protocol test"
    - path: "pkg/warplib/testdata/pre_phase2_userdata.warp"
      provides: "Binary GOB fixture encoded WITHOUT Protocol field, used for backward compat assertion"
    - path: "pkg/warplib/testdata/generate_fixture_test.go"
      provides: "Test that generates the fixture file (run once manually, then committed)"
  key_links:
    - from: "pkg/warplib/item.go:Item.Protocol"
      to: "pkg/warplib/manager.go:InitManager GOB decode"
      via: "GOB decoder automatically zero-initializes missing Protocol field"
      pattern: "Protocol.*Protocol"
    - from: "pkg/warplib/testdata/pre_phase2_userdata.warp"
      to: "pkg/warplib/protocol_gob_test.go:TestGOBBackwardCompatProtocol"
      via: "Fixture loaded and decoded to verify backward compat"
      pattern: "pre_phase2_userdata\\.warp"
---

<objective>
Add the Protocol enum to Item, create the GOB backward compatibility golden fixture, and verify round-trip persistence.

Purpose: Phase 3 (FTP) and Phase 4 (SFTP) will set Item.Protocol to non-zero values. When the manager resumes a download, it needs to know which protocol factory to use. The Protocol field must be backward-compatible with all existing GOB-encoded userdata.warp files — zero value (ProtoHTTP=0) must be the default for items encoded before this field existed. A golden fixture test locks this invariant permanently.

Output: Protocol type in item.go (or protocol.go), golden fixture binary, and comprehensive GOB tests.
</objective>

<execution_context>
@/Users/divkix/.claude/get-shit-done/workflows/execute-plan.md
@/Users/divkix/.claude/get-shit-done/templates/summary.md
@/Users/divkix/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/02-protocol-interface/02-CONTEXT.md
@.planning/phases/02-protocol-interface/02-RESEARCH.md
@.planning/phases/02-protocol-interface/02-01-PLAN.md

@pkg/warplib/item.go
@pkg/warplib/manager.go
@pkg/warplib/protocol.go  (created by Plan 02-01)
</context>

<interfaces>
<!-- Key types and contracts the executor needs. -->

From pkg/warplib/item.go (after Plan 02-01):
```go
type Item struct {
    Hash             string            `json:"hash"`
    Name             string            `json:"name"`
    Url              string            `json:"url"`
    Headers          Headers           `json:"headers"`
    DateAdded        time.Time         `json:"date_added"`
    TotalSize        ContentLength     `json:"total_size"`
    Downloaded       ContentLength     `json:"downloaded"`
    DownloadLocation string            `json:"download_location"`
    AbsoluteLocation string            `json:"absolute_location"`
    ChildHash        string            `json:"child_hash"`
    Hidden           bool              `json:"hidden"`
    Children         bool              `json:"children"`
    Parts            map[int64]*ItemPart `json:"parts"`
    Resumable        bool              `json:"resumable"`
    // Protocol field will be ADDED by this plan:
    // Protocol Protocol `json:"protocol"`
    mu       *sync.RWMutex
    dAllocMu sync.RWMutex
    dAlloc   ProtocolDownloader  // Changed by Plan 02-01
    memPart  map[string]int64
}
```

From pkg/warplib/manager.go — GOB encoding/decoding:
```go
type ManagerData struct {
    Items      ItemsMap
    QueueState *QueueState
}

// InitManager decodes GOB from file:
gob.NewDecoder(m.f).Decode(&data)  // data is ManagerData

// persistItems encodes GOB:
gob.NewEncoder(&buf).Encode(data)
```

GOB behavior (from Go stdlib docs):
- Missing fields in the stream are zero-initialized in the target struct
- Extra fields in the stream (not in target) are silently skipped
- This means: old GOB (no Protocol) + new struct (has Protocol) = Protocol == 0 == ProtoHTTP
</interfaces>

<feature>
  <name>Protocol Enum and GOB Backward Compatibility</name>
  <files>pkg/warplib/item.go, pkg/warplib/protocol.go, pkg/warplib/protocol_gob_test.go, pkg/warplib/testdata/pre_phase2_userdata.warp, pkg/warplib/testdata/generate_fixture_test.go</files>
  <behavior>
    Test cases:

    GOB backward compatibility:
    1. Decode pre_phase2_userdata.warp fixture: all items have Protocol==ProtoHTTP (0)
    2. Fixture contains at least 2 items with different hashes, sizes, and part counts
    3. Decoded items retain all original field values (Hash, Name, Url, TotalSize, Downloaded, Parts, Resumable)

    Protocol type:
    4. ProtoHTTP == 0 (critical for backward compat — if this ever changes, all old files break)
    5. ProtoFTP == 1
    6. ProtoFTPS == 2
    7. ProtoSFTP == 3
    8. Protocol(0).String() == "http"
    9. Protocol(1).String() == "ftp"
    10. Protocol(2).String() == "ftps"
    11. Protocol(3).String() == "sftp"
    12. Protocol(7).String() == "unknown(7)"

    GOB round-trip:
    13. Encode ManagerData with Item.Protocol==ProtoHTTP, decode, assert Protocol==ProtoHTTP
    14. Encode ManagerData with Item.Protocol==ProtoFTP, decode, assert Protocol==ProtoFTP
    15. Encode ManagerData with Item.Protocol==ProtoSFTP, decode, assert Protocol==ProtoSFTP

    GOB unknown protocol:
    16. Manually encode a ManagerData with Protocol set to 7 (uint8). Decode succeeds (GOB doesn't validate enum ranges). Protocol field == 7. String() returns "unknown(7)".
    17. Add a ValidateProtocol(p Protocol) error function that returns error for unknown values. Manager can call this during decode to fail with "unknown protocol type 7 — upgrade warpdl". Test this function.

    Persistence integration:
    18. Manager.persistItems with items containing Protocol field encodes without error
    19. Manager.InitManager with the encoded data decodes with correct Protocol values
  </behavior>
  <implementation>
    STEP 1: Generate the golden fixture BEFORE adding Protocol field

    CRITICAL ORDERING: The fixture must be generated using the current Item struct that does NOT have a Protocol field. If we add Protocol first and then generate the fixture, the fixture will contain the Protocol field and the backward compat test is meaningless.

    Approach: The fixture generation is a one-time manual step. Create a helper test (generate_fixture_test.go) that:
    - Builds a ManagerData with 2 items (different hashes, sizes, resumable states, parts)
    - Encodes to GOB
    - Writes to testdata/pre_phase2_userdata.warp
    - This test is run ONCE before the Protocol field is added to Item
    - The generated file is committed to the repo
    - After committing, the test can remain but should be guarded by a build tag or flag

    NOTE: Since Plan 02-01 (wave 1) runs first and may modify item.go (changing dAlloc type), the fixture generation must happen at the START of Plan 02-02, BEFORE adding the Protocol field. The dAlloc field is unexported and not GOB-encoded, so changing its type does not affect GOB encoding. The fixture will correctly represent a pre-Protocol Item.

    ```go
    // pkg/warplib/testdata/generate_fixture_test.go
    //go:build ignore

    package testdata

    // Run: go test -run TestGeneratePrePhase2Fixture -tags ignore ./pkg/warplib/testdata/
    // Then commit the generated file.
    func TestGeneratePrePhase2Fixture(t *testing.T) { ... }
    ```

    Actually, since this needs access to warplib internals (ManagerData, Item, ItemPart, ItemsMap), it should live in pkg/warplib/ with package warplib, not in testdata/. The fixture file goes in testdata/ but the generator test is in the warplib package.

    STEP 2: Add Protocol type

    In pkg/warplib/protocol.go (or item.go — protocol.go is cleaner since it's the protocol abstraction file):
    ```go
    type Protocol uint8

    const (
        ProtoHTTP  Protocol = iota // 0 — default, backward compat
        ProtoFTP                   // 1
        ProtoFTPS                  // 2
        ProtoSFTP                  // 3
    )

    func (p Protocol) String() string { ... }

    // ValidateProtocol returns an error if the protocol value is unknown.
    func ValidateProtocol(p Protocol) error {
        switch p {
        case ProtoHTTP, ProtoFTP, ProtoFTPS, ProtoSFTP:
            return nil
        default:
            return fmt.Errorf("unknown protocol type %d — upgrade warpdl", uint8(p))
        }
    }
    ```

    STEP 3: Add Protocol field to Item

    In pkg/warplib/item.go:
    ```go
    type Item struct {
        // ... existing fields ...
        Protocol Protocol `json:"protocol"`
        // ... unexported fields ...
    }
    ```

    Place it after Resumable (last exported GOB-encoded field). GOB field matching is by name, not position, so placement doesn't matter for encoding — but it matters for readability.

    STEP 4: Write tests

    In pkg/warplib/protocol_gob_test.go:
    - TestGOBBackwardCompatProtocol: loads fixture, decodes, asserts Protocol==ProtoHTTP for all items
    - TestGOBRoundTrip: encodes with ProtoHTTP, decodes, asserts
    - TestGOBRoundTripFTP: encodes with ProtoFTP, decodes, asserts
    - TestGOBRoundTripSFTP: encodes with ProtoSFTP, decodes, asserts
    - TestGOBUnknownProtocol: manually encodes uint8(7), decodes, asserts field value and ValidateProtocol error
    - TestProtocolString: table-driven tests for String() method
    - TestProtocolConstants: asserts ProtoHTTP==0, ProtoFTP==1, ProtoFTPS==2, ProtoSFTP==3 (prevents accidental reordering)
    - TestValidateProtocol: known values return nil, unknown returns error with "upgrade warpdl"

    STEP 5: Optionally add protocol validation to InitManager decode path

    In manager.go InitManager, after decoding ManagerData, iterate items and call ValidateProtocol. Log warning or return error for unknown protocols. Per CONTEXT.md: "Unknown protocol values fail with clear error: unknown protocol type 7 — upgrade warpdl — no silent degradation."

    This is a small addition to InitManager:
    ```go
    for hash, item := range m.items {
        if err := ValidateProtocol(item.Protocol); err != nil {
            return nil, fmt.Errorf("item %s: %w", hash, err)
        }
    }
    ```
  </implementation>
</feature>

<verification>
```bash
# Generate fixture FIRST (one-time, before adding Protocol field)
# This step is manual — executor must run it at the right time
go test -v -run TestGeneratePrePhase2Fixture ./pkg/warplib/ -count=1

# After adding Protocol field and tests:
go test -v -run "TestGOB|TestProtocol|TestValidateProtocol" ./pkg/warplib/ -count=1

# Regression — ALL existing tests must still pass
go test ./pkg/warplib/ -count=1

# Full suite
go test ./... -count=1

# Race detection
go test -race -short ./pkg/warplib/

# Coverage check
go test -cover ./pkg/warplib/

# Vet
go vet ./...
```
</verification>

<success_criteria>
- RED: Failing tests exist for GOB backward compat, round-trip, unknown protocol, Protocol constants, String()
- GREEN: All tests pass after Protocol type and field are added
- REFACTOR: Clean code, no duplication
- Golden fixture file (pre_phase2_userdata.warp) exists in testdata/ and is committed
- Fixture was generated BEFORE Protocol field was added to Item (verified by the fact that the fixture decodes correctly with Protocol==0)
- ProtoHTTP == 0 is asserted explicitly (regression guard against iota reordering)
- ValidateProtocol rejects unknown values with descriptive error
- InitManager rejects items with unknown Protocol values
- All existing tests pass — zero regression
- go vet ./... clean
- Coverage remains >= 80% on pkg/warplib
</success_criteria>

<output>
After completion, create `.planning/phases/02-protocol-interface/02-02-SUMMARY.md`
</output>
