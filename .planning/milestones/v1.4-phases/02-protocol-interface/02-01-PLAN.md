---
phase: 02-protocol-interface
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - pkg/warplib/protocol.go
  - pkg/warplib/protocol_http.go
  - pkg/warplib/protocol_router.go
  - pkg/warplib/protocol_test.go
  - pkg/warplib/protocol_http_test.go
  - pkg/warplib/protocol_router_test.go
  - pkg/warplib/item.go
  - pkg/warplib/manager.go
  - pkg/warplib/errors.go
autonomous: true
requirements: [PROTO-01, PROTO-02]

must_haves:
  truths:
    - "ProtocolDownloader interface exists with Probe, Download, Resume, Capabilities, Close, Stop, IsStopped, GetMaxConnections, GetMaxParts, GetHash, GetFileName, GetDownloadDirectory, GetSavePath, GetContentLength methods"
    - "httpProtocolDownloader adapter wraps existing *Downloader and satisfies ProtocolDownloader — compile-time check via var _ ProtocolDownloader = (*httpProtocolDownloader)(nil)"
    - "DownloadError type implements error, Unwrap, IsTransient; manager can use errors.As to classify transient vs permanent"
    - "DownloadCapabilities struct with SupportsParallel and SupportsResume fields returned by Capabilities()"
    - "Scheme router resolves http/https to httpProtocolDownloader factory; unsupported schemes return descriptive error listing supported schemes"
    - "Router handles mixed-case schemes (HTTP://, HTTPS://) correctly via strings.ToLower"
    - "Calling Download/Resume without Probe returns descriptive error, not a nil panic"
    - "Item.dAlloc is changed from *Downloader to ProtocolDownloader — all existing Item methods (GetMaxConnections, GetMaxParts, Resume, StopDownload, CloseDownloader, IsDownloading, IsStopped) compile and work"
    - "Manager.AddDownload and Manager.ResumeDownload still work with existing HTTP flow (zero regression)"
    - "All existing tests pass with no changes to their assertions (only type changes if needed)"
  artifacts:
    - path: "pkg/warplib/protocol.go"
      provides: "ProtocolDownloader interface, DownloadCapabilities, ProbeResult, DownloadError, DownloaderFactory, NewProtocolDownloader"
      exports: ["ProtocolDownloader", "DownloadCapabilities", "ProbeResult", "DownloadError", "DownloaderFactory", "NewProtocolDownloader"]
    - path: "pkg/warplib/protocol_http.go"
      provides: "httpProtocolDownloader adapter wrapping *Downloader"
      exports: ["newHTTPProtocolDownloader"]
    - path: "pkg/warplib/protocol_router.go"
      provides: "Static scheme-to-factory map and NewProtocolDownloader dispatcher"
      exports: ["NewProtocolDownloader", "SupportedSchemes"]
    - path: "pkg/warplib/protocol_test.go"
      provides: "Interface compliance, DownloadError, mock downloader, Probe-before-Download guard tests"
    - path: "pkg/warplib/protocol_http_test.go"
      provides: "httpProtocolDownloader adapter integration tests against httptest server"
    - path: "pkg/warplib/protocol_router_test.go"
      provides: "Scheme router tests: supported, unsupported, case-insensitive, empty/invalid"
  key_links:
    - from: "pkg/warplib/item.go:dAlloc"
      to: "pkg/warplib/protocol.go:ProtocolDownloader"
      via: "dAlloc type change from *Downloader to ProtocolDownloader"
      pattern: "dAlloc\\s+ProtocolDownloader"
    - from: "pkg/warplib/manager.go:AddDownload"
      to: "pkg/warplib/protocol.go:ProtocolDownloader"
      via: "Manager.AddDownload accepts ProtocolDownloader instead of *Downloader"
      pattern: "AddDownload\\(.*ProtocolDownloader"
    - from: "pkg/warplib/protocol_router.go:defaultSchemeRouter"
      to: "pkg/warplib/protocol_http.go:newHTTPProtocolDownloader"
      via: "http/https mapped to HTTP factory"
      pattern: "\"http\".*newHTTPProtocolDownloader"
---

<objective>
Extract the ProtocolDownloader interface, build the httpProtocolDownloader adapter, create the scheme router, and update Item/Manager to use the interface.

Purpose: The existing download engine is hardcoded to `*Downloader` (HTTP-only). This plan introduces a protocol-agnostic `ProtocolDownloader` interface so that FTP (Phase 3) and SFTP (Phase 4) backends can plug in without modifying the manager, item, or API layers. The adapter pattern wraps the existing `*Downloader` without disturbing its 87.1% test coverage.

Output: protocol.go (interface + types), protocol_http.go (adapter), protocol_router.go (scheme dispatcher), updated item.go and manager.go, and comprehensive tests.
</objective>

<execution_context>
@/Users/divkix/.claude/get-shit-done/workflows/execute-plan.md
@/Users/divkix/.claude/get-shit-done/templates/summary.md
@/Users/divkix/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/02-protocol-interface/02-CONTEXT.md
@.planning/phases/02-protocol-interface/02-RESEARCH.md

@pkg/warplib/dloader.go
@pkg/warplib/item.go
@pkg/warplib/manager.go
@pkg/warplib/handlers.go
@pkg/warplib/errors.go
</context>

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From pkg/warplib/dloader.go — existing Downloader methods that must be exposed through the interface:
```go
// These methods are called via item.dAlloc or directly from internal/api:
func (d *Downloader) Start() error                  // Called by api/download.go: go d.Start()
func (d *Downloader) Resume(parts map[int64]*ItemPart) error  // Called by Item.Resume()
func (d *Downloader) Stop()                          // Called by Item.StopDownload()
func (d *Downloader) Close() error                   // Called by Item.CloseDownloader()
func (d *Downloader) IsStopped() bool                // Called by Item.IsStopped(), api/download.go
func (d *Downloader) GetMaxConnections() int32       // Called by Item.GetMaxConnections(), api/download.go, api/attach.go, api/resume.go
func (d *Downloader) GetMaxParts() int32             // Called by Item.GetMaxParts(), api/download.go, api/attach.go, api/resume.go
func (d *Downloader) GetHash() string                // Called by api/download.go (d.GetHash())
func (d *Downloader) GetFileName() string            // Called by api/download.go
func (d *Downloader) GetDownloadDirectory() string   // Called by api/download.go
func (d *Downloader) GetSavePath() string            // Called by api/download.go
func (d *Downloader) GetContentLength() ContentLength // Called by api/download.go
```

From pkg/warplib/item.go — dAlloc field and its accessors:
```go
type Item struct {
    // dAlloc is *Downloader today — will become ProtocolDownloader
    dAlloc *Downloader
    dAllocMu sync.RWMutex
}
func (i *Item) getDAlloc() *Downloader           // returns dAlloc
func (i *Item) setDAlloc(d *Downloader)          // sets dAlloc
func (i *Item) clearDAlloc()                     // sets dAlloc = nil
func (i *Item) GetMaxConnections() (int32, error) // delegates to dAlloc.GetMaxConnections()
func (i *Item) GetMaxParts() (int32, error)       // delegates to dAlloc.GetMaxParts()
func (i *Item) Resume() error                     // delegates to dAlloc.Resume(partsCopy)
func (i *Item) StopDownload() error               // calls dAlloc.Stop(); dAlloc = nil
func (i *Item) CloseDownloader() error            // calls dAlloc.Close(); dAlloc = nil
func (i *Item) IsDownloading() bool               // returns dAlloc != nil
func (i *Item) IsStopped() bool                   // delegates to dAlloc.IsStopped()
```

From pkg/warplib/manager.go — patchHandlers coupling:
```go
func (m *Manager) patchHandlers(d *Downloader, item *Item) {
    // Directly accesses d.handlers.SpawnPartHandler, etc.
    // Must be refactored to work through ProtocolDownloader
}
func (m *Manager) AddDownload(d *Downloader, opts *AddDownloadOpts) error {
    // Uses d.fileName, d.url, d.dlLoc, d.hash, d.contentLength, d.resumable, d.headers
    // These are unexported fields — the adapter must expose them
}
func (m *Manager) ResumeDownload(client *http.Client, hash string, opts *ResumeDownloadOpts) (*Item, error) {
    // Creates *Downloader via initDownloader, calls patchHandlers, sets dAlloc
}
```

From internal/api/download.go — direct *Downloader usage:
```go
d, err = warplib.NewDownloader(dlClient, url, &warplib.DownloaderOpts{...})
// Then uses: d.GetHash(), d.GetFileName(), d.GetSavePath(), d.GetDownloadDirectory(),
//            d.GetContentLength(), d.GetMaxConnections(), d.GetMaxParts(),
//            d.IsStopped(), d.Start()
// Also: s.manager.AddDownload(d, ...)
```

From internal/api/attach.go, internal/api/resume.go — external callers of Item methods:
```go
maxConn, err := item.GetMaxConnections()
maxParts, err := item.GetMaxParts()
```

From pkg/warplib test files — direct dAlloc access:
```go
// manager_resume_test.go, manager_test.go, cookie_persistence_test.go:
defer resumed.dAlloc.Close()  // Must work with ProtocolDownloader
```
</interfaces>

<feature>
  <name>ProtocolDownloader Interface and HTTP Adapter</name>
  <files>pkg/warplib/protocol.go, pkg/warplib/protocol_http.go, pkg/warplib/protocol_router.go, pkg/warplib/protocol_test.go, pkg/warplib/protocol_http_test.go, pkg/warplib/protocol_router_test.go, pkg/warplib/item.go, pkg/warplib/manager.go, pkg/warplib/errors.go</files>
  <behavior>
    Test cases for PROTO-01 (interface):
    1. ProtocolDownloader interface exists; httpProtocolDownloader satisfies it (compile-time check)
    2. Mock downloader implementing ProtocolDownloader can be used in place of real downloader
    3. DownloadError.Error() returns "protocol op: cause" format
    4. DownloadError.Unwrap() returns the cause error
    5. DownloadError.IsTransient() returns true for transient errors, false for permanent
    6. errors.As(err, &de) works correctly for wrapped DownloadError
    7. DownloadCapabilities struct defaults to zero values (false, false) — safe for unknown protocols
    8. ProbeResult defaults: ContentLength == -1 for unknown size, FileName empty, Resumable false
    9. Calling httpProtocolDownloader.Download() without Probe() returns ErrProbeRequired
    10. Calling httpProtocolDownloader.Resume() without Probe() returns ErrProbeRequired
    11. httpProtocolDownloader.Capabilities() returns SupportsParallel=true after Probe when Accept-Ranges present
    12. httpProtocolDownloader.Capabilities() returns SupportsResume=true after Probe when Accept-Ranges present

    Test cases for PROTO-02 (router):
    13. NewProtocolDownloader("http://example.com/file") returns non-nil httpProtocolDownloader
    14. NewProtocolDownloader("https://example.com/file") returns non-nil httpProtocolDownloader
    15. NewProtocolDownloader("magnet:?xt=...") returns error containing "unsupported scheme" and listing supported schemes
    16. NewProtocolDownloader("HTTP://EXAMPLE.COM/file") succeeds (case-insensitive)
    17. NewProtocolDownloader("") returns error (empty URL)
    18. NewProtocolDownloader("://noscheme") returns error (invalid URL)

    Integration/regression tests:
    19. Item.dAlloc as ProtocolDownloader: GetMaxConnections, GetMaxParts, Resume, StopDownload, CloseDownloader all work
    20. Manager.AddDownload with *Downloader (via adapter) still works — existing test patterns pass
    21. All existing tests in pkg/warplib pass without assertion changes
  </behavior>
  <implementation>
    PHASE A: Interface and Types (protocol.go)

    1. Create pkg/warplib/protocol.go with:
       - DownloadCapabilities struct { SupportsParallel, SupportsResume bool }
       - ProbeResult struct { FileName string; ContentLength int64; Resumable bool; Checksums []ExpectedChecksum }
       - ProtocolDownloader interface with methods:
         * Probe(ctx context.Context) (ProbeResult, error)
         * Download(ctx context.Context, handlers *Handlers) error
         * Resume(ctx context.Context, parts map[int64]*ItemPart, handlers *Handlers) error
         * Capabilities() DownloadCapabilities
         * Close() error
         * Stop()
         * IsStopped() bool
         * GetMaxConnections() int32
         * GetMaxParts() int32
         * GetHash() string
         * GetFileName() string
         * GetDownloadDirectory() string
         * GetSavePath() string
         * GetContentLength() ContentLength
       - DownloadError struct { Protocol, Op string; Cause error; transient bool }
         * Error(), Unwrap(), IsTransient() methods
         * NewTransientError(protocol, op string, cause error) constructor
         * NewPermanentError(protocol, op string, cause error) constructor
       - DownloaderFactory type: func(rawURL string, opts *DownloaderOpts) (ProtocolDownloader, error)
       - ErrProbeRequired sentinel error

    PHASE B: HTTP Adapter (protocol_http.go)

    2. Create pkg/warplib/protocol_http.go with httpProtocolDownloader:
       - Fields: inner *Downloader, client *http.Client, rawURL string, opts *DownloaderOpts, probed bool
       - Probe(ctx): calls NewDownloader(client, rawURL, opts) to create inner *Downloader (which runs fetchInfo internally). Stores result. Sets probed=true. Returns ProbeResult from inner fields.
       - Download(ctx, handlers): checks probed==true (else ErrProbeRequired). Patches handlers into inner.handlers. Calls inner.Start().
       - Resume(ctx, parts, handlers): checks probed==true. Patches handlers. Calls inner.Resume(parts).
       - Capabilities(): returns { SupportsParallel: inner.resumable && inner.maxConn > 1, SupportsResume: inner.resumable }. If inner==nil, returns zero value.
       - Close(): calls inner.Close() if inner != nil.
       - Stop(): calls inner.Stop() if inner != nil.
       - IsStopped(): delegates to inner.IsStopped() if inner != nil; else returns true.
       - GetMaxConnections(), GetMaxParts(), GetHash(), GetFileName(), GetDownloadDirectory(), GetSavePath(), GetContentLength(): delegate to inner.
       - Compile-time check: var _ ProtocolDownloader = (*httpProtocolDownloader)(nil)

    3. Factory function newHTTPProtocolDownloader(rawURL string, opts *DownloaderOpts) (ProtocolDownloader, error):
       - Creates and returns &httpProtocolDownloader{rawURL: rawURL, opts: opts, client: opts.Client or http.DefaultClient}
       - NOTE: opts needs a Client field OR the factory needs a separate client parameter.
       - DECISION: Add a Client field to a new httpDownloaderOpts struct internal to the factory, or use a closure. Simplest: the factory is a method on a struct that holds the *http.Client, or the DownloaderFactory signature includes the client. Since the CONTEXT.md says factory signature is `func(rawURL string, opts *DownloaderOpts)`, and DownloaderOpts doesn't have a Client field, the factory must capture the client via closure.
       - The scheme router's RegisterHTTP(client) method sets up the closure. Or: the defaultSchemeRouter is built by a function that takes *http.Client.

    PHASE C: Scheme Router (protocol_router.go)

    4. Create pkg/warplib/protocol_router.go:
       - SchemeRouter struct with routes map[string]DownloaderFactory
       - NewSchemeRouter(client *http.Client) *SchemeRouter: builds default routes for http/https
       - (r *SchemeRouter) Register(scheme string, factory DownloaderFactory): for future FTP/SFTP
       - (r *SchemeRouter) NewDownloader(rawURL string, opts *DownloaderOpts) (ProtocolDownloader, error):
         * Parses URL, lowercases scheme, looks up factory
         * Returns descriptive error for unsupported scheme: "unsupported scheme %q — supported: %s"
       - SupportedSchemes(r *SchemeRouter) []string: returns sorted list of registered schemes
       - No global var — Manager holds a *SchemeRouter instance

    PHASE D: Item and Manager Refactor

    5. Update pkg/warplib/item.go:
       - Change dAlloc from *Downloader to ProtocolDownloader
       - getDAlloc() returns ProtocolDownloader
       - setDAlloc(d ProtocolDownloader)
       - All delegating methods (GetMaxConnections, GetMaxParts, Resume, StopDownload, CloseDownloader, IsStopped) already call methods that will be on the interface — no logic changes needed, only type changes.

    6. Update pkg/warplib/manager.go:
       - Manager gets a schemeRouter *SchemeRouter field
       - InitManager creates SchemeRouter (needs *http.Client — add parameter or lazy init)
       - AddDownload signature change: accept ProtocolDownloader instead of *Downloader
         * Extract metadata via pd.GetFileName(), pd.GetHash(), pd.GetContentLength(), etc.
         * Item construction uses these instead of d.fileName, d.url, etc. (unexported)
         * patchHandlers refactor: the ProtocolDownloader.Download/Resume methods accept *Handlers, so patchHandlers produces a wrapped *Handlers that the caller passes into Download/Resume. The manager calls pd.Download(ctx, patchedHandlers) instead of go d.Start(). BUT: the current flow in api/download.go calls AddDownload THEN go d.Start() separately. The manager.AddDownload stores the downloader in item.dAlloc but doesn't call Start.
         * KEY INSIGHT: Manager.AddDownload should NOT call Download. It just stores the downloader. The caller (api/download.go) calls Start/Download separately. So patchHandlers must still modify the downloader's handlers. The httpProtocolDownloader adapter can expose SetHandlers or accept handlers in Download.
         * SIMPLEST PATH: Keep patchHandlers working on the concrete *Downloader for now. The adapter's Download method uses the inner downloader's handlers that were already patched. Manager.AddDownload receives ProtocolDownloader, type-asserts to *httpProtocolDownloader to get inner *Downloader for patchHandlers. This is ugly but works for Phase 2.
         * BETTER PATH: Add a method to ProtocolDownloader that allows handler patching. Or: AddDownload receives the *Handlers, patches them, and stores them. When Start is called later, the patched handlers are used. This requires the interface to have a way to set handlers after construction.
         * CLEANEST PATH (chosen): ProtocolDownloader gets a SetHandlers(h *Handlers) method. The adapter's SetHandlers updates inner.handlers. Manager.AddDownload calls pd.SetHandlers to install patched handlers. No type assertions needed. FTP/SFTP adapters in Phase 3/4 will implement SetHandlers similarly.
         * WAIT — CONTEXT.md says "all protocols accept the same handler callbacks that HTTP uses today — manager and UI code stays protocol-agnostic." And RESEARCH.md says handlers should be threaded as parameters in Download/Resume. But the current flow is: AddDownload -> patchHandlers -> (later) go d.Start(). Start() doesn't take handlers. The adapter's Download(ctx, handlers) method will be called instead of Start(). So the adapter internally calls d.Start() after applying the handlers.
         * REVISED FLOW: Manager.AddDownload(pd ProtocolDownloader, opts):
           1. Extract metadata from pd (GetFileName, GetHash, etc.)
           2. Create Item
           3. Store pd in item.dAlloc
           4. Return item — caller is responsible for calling pd.Download(ctx, handlers) later
           Actually, we need to keep backward compat with api/download.go which calls:
             s.manager.AddDownload(d, opts)
             go d.Start()
           We can't change api/download.go in this phase (or we can, minimally).

         * PRAGMATIC DECISION: Keep the existing AddDownload/patchHandlers flow working by adding GetHandlers()/SetHandlers() to ProtocolDownloader. The httpProtocolDownloader delegates to inner.handlers. patchHandlers takes ProtocolDownloader (not *Downloader), calls pd.GetHandlers() to get the *Handlers pointer, wraps callbacks, and the mutations propagate through the pointer. Since handlers is already a pointer field, this works.

    7. Update AddDownload to accept ProtocolDownloader:
       - AddDownload(pd ProtocolDownloader, opts *AddDownloadOpts) error
       - Uses pd.GetFileName(), pd.GetHash(), pd.GetContentLength(), pd.GetSavePath() to extract metadata
       - NOTE: We also need url, dlLoc, resumable, headers from the downloader. These are not on the interface.
       - Add to interface: GetURL() string, GetHeaders() Headers, IsResumable() bool
       - Actually, a cleaner approach: AddDownload takes the ProtocolDownloader plus all metadata needed. Or better: the ProbeResult already has FileName, ContentLength, Resumable. AddDownload gets them from ProbeResult + the URL passed by the caller.
       - CLEANEST: Don't change AddDownload signature at all for now. Keep it taking *Downloader. The api layer still creates *Downloader. The only change in this phase is: Item.dAlloc becomes ProtocolDownloader. Manager.ResumeDownload internally creates ProtocolDownloader. AddDownload stays *Downloader for Phase 2. Phase 3/4 adds a second method or generalizes it.
       - THIS IS THE RIGHT CALL. Minimal surgery. The critical abstraction for Phase 2 is: Item.dAlloc is ProtocolDownloader, ResumeDownload uses SchemeRouter, and the interface is defined. AddDownload's signature can stay *Downloader because the only callers in Phase 2 still use HTTP. Phase 3 introduces AddProtocolDownload or refactors AddDownload.
       - BUT: we still need to setDAlloc to ProtocolDownloader in AddDownload. Since AddDownload takes *Downloader, we wrap it: item.setDAlloc(wrapDownloader(d)). Or just: *Downloader satisfies a subset of ProtocolDownloader? No — *Downloader doesn't implement ProtocolDownloader.
       - FINAL DECISION: AddDownload takes *Downloader, wraps it in httpProtocolDownloader internally, stores the adapter in item.dAlloc. patchHandlers still takes *Downloader (concrete). This is zero-risk.

    8. Update ResumeDownload to use SchemeRouter:
       - Currently creates *Downloader via initDownloader. After Phase 2:
       - Look at item.Protocol field (added in Plan 02-02). If ProtoHTTP (or zero): use current initDownloader path. If ProtoFTP/SFTP: use SchemeRouter. But Phase 2 only implements HTTP — so this is effectively a no-op for now. Add the Protocol check but only HTTP path exists.
       - patchHandlers stays concrete *Downloader for the HTTP path.
       - The adapter wraps the *Downloader for storage in item.dAlloc.

    SUMMARY OF CHANGES:
    - NEW: protocol.go (interface, types, errors)
    - NEW: protocol_http.go (adapter wrapping *Downloader)
    - NEW: protocol_router.go (SchemeRouter struct, http/https registration)
    - MODIFIED: item.go — dAlloc type change to ProtocolDownloader, accessor type changes
    - MODIFIED: manager.go — AddDownload wraps *Downloader in adapter before setDAlloc; ResumeDownload wraps in adapter before setDAlloc; Manager gains SchemeRouter field
    - MODIFIED: errors.go — add ErrProbeRequired, ErrUnsupportedScheme
    - Test files: verify all above
  </implementation>
</feature>

<verification>
```bash
# Per-task TDD cycle
go test -v -run "TestProtocolDownloader|TestDownloadError|TestDownloadCapabilities|TestProbeResult" ./pkg/warplib/ -count=1
go test -v -run "TestHTTPAdapter|TestHTTPProtocol" ./pkg/warplib/ -count=1
go test -v -run "TestSchemeRouter" ./pkg/warplib/ -count=1

# Regression — ALL existing tests must still pass
go test ./pkg/warplib/ -count=1

# Race detection
go test -race -short ./pkg/warplib/

# Full suite including internal packages that use Item/Manager
go test ./... -count=1

# Coverage check
go test -cover ./pkg/warplib/

# Vet
go vet ./...
```
</verification>

<success_criteria>
- RED: Failing tests exist for interface compliance, DownloadError, scheme router, Probe-before-Download guard
- GREEN: All tests pass with implementation
- REFACTOR: Clean separation — no type assertions in item.go or manager.go public methods
- ProtocolDownloader interface defined with all methods needed by Item and API layers
- httpProtocolDownloader adapter passes compile-time interface check
- SchemeRouter resolves http/https correctly, rejects unsupported schemes with descriptive error
- Item.dAlloc is ProtocolDownloader — all Item methods compile and work
- Manager.AddDownload wraps *Downloader in adapter — zero regression
- Manager.ResumeDownload wraps in adapter — zero regression
- All existing tests pass (pkg/warplib, internal/api, cmd) — zero regression
- go vet ./... clean
- Coverage remains >= 80% on pkg/warplib
</success_criteria>

<output>
After completion, create `.planning/phases/02-protocol-interface/02-01-SUMMARY.md`
</output>
