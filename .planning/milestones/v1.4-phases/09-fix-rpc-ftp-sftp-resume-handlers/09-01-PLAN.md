---
phase: 09-fix-rpc-ftp-sftp-resume-handlers
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - pkg/warplib/item.go
  - pkg/warplib/manager.go
  - internal/server/rpc_ftp_sftp_notify_test.go
  - internal/server/rpc_ftp_sftp_resume_test.go
requirements:
  - RPC-06
  - RPC-11
autonomous: true

must_haves:
  truths:
    - "FTP/SFTP downloads resumed via JSON-RPC `download.resume` emit WebSocket push notifications (download.progress, download.complete, download.error) to connected clients"
    - "`Item.Resume()` passes stored `resumeHandlers` (not nil) to `ProtocolDownloader.Resume()` for FTP/SFTP items"
    - "HTTP resume path remains unaffected: `resumeHandlers` stays nil for HTTP items, so `httpProtocolDownloader.Resume` continues using `patchHandlers`-installed struct field handlers"
    - "Tests prove handler callbacks are invoked during FTP/SFTP RPC download.resume (atomic counters on mock)"
    - "All tests pass with `-race` flag (handlers set before goroutine launch — happens-before guarantee)"
    - "GOB backward compatibility preserved: `resumeHandlers` field is unexported, GOB skips it"
    - "Server and warplib package test coverage remains >= 80%"
  artifacts:
    - path: "pkg/warplib/item.go"
      provides: "Unexported `resumeHandlers *Handlers` field on Item, `setResumeHandlers`/`getResumeHandlers` methods, `Resume()` passes stored handlers to `d.Resume()`"
    - path: "pkg/warplib/manager.go"
      provides: "One new line in `ResumeDownload` FTP/FTPS/SFTP branch: `item.setResumeHandlers(opts.Handlers)` after `patchProtocolHandlers`"
    - path: "internal/server/rpc_ftp_sftp_resume_test.go"
      provides: "Integration tests verifying handler callbacks fire during FTP/SFTP RPC download.resume"
    - path: "internal/server/rpc_ftp_sftp_notify_test.go"
      provides: "Updated mockProtocolDownloader.Resume to invoke handler callbacks and signal completion"
  key_links:
    - from: "pkg/warplib/manager.go:ResumeDownload (FTP/SFTP branch)"
      to: "pkg/warplib/item.go:setResumeHandlers"
      via: "Stores patched handlers on Item after patchProtocolHandlers completes"
      pattern: "item\\.setResumeHandlers\\(opts\\.Handlers\\)"
    - from: "pkg/warplib/item.go:Resume"
      to: "pkg/warplib/protocol.go:ProtocolDownloader.Resume"
      via: "Passes stored resumeHandlers (non-nil for FTP/SFTP, nil for HTTP) to d.Resume()"
      pattern: "d\\.Resume\\(context\\.Background\\(\\), partsCopy, h\\)"
    - from: "internal/server/rpc_methods.go:downloadResume"
      to: "pkg/warplib/item.go:Resume"
      via: "go resumedItem.Resume() — handlers reach d.Resume via stored field"
      pattern: "go resumedItem\\.Resume\\(\\)"
---

<objective>
Store patched handlers on Item during FTP/SFTP resume and pass them through to ProtocolDownloader.Resume() so WebSocket push notifications fire.

Purpose: After this plan, FTP/SFTP downloads resumed via JSON-RPC `download.resume` will emit WebSocket push notifications (progress/complete/error) and update `item.Downloaded` during resume (fixing INT-02 tech debt).

Output: 3 production changes (new field + 2 methods on Item, 1 new line in manager.go), updated mock Resume method, new test file with 2 integration tests.
</objective>

<execution_context>
@/Users/divkix/.claude/get-shit-done/workflows/execute-plan.md
@/Users/divkix/.claude/get-shit-done/templates/summary.md
@/Users/divkix/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/09-fix-rpc-ftp-sftp-resume-handlers/09-RESEARCH.md

@pkg/warplib/item.go (lines 18-66: Item struct with unexported fields; lines 182-186: setDAlloc; lines 262-284: Resume method)
@pkg/warplib/manager.go (lines 588-615: ResumeDownload FTP/SFTP branch — patchProtocolHandlers then setDAlloc)
@pkg/warplib/protocol_http.go (lines 69-77: httpProtocolDownloader.Resume replaces h.inner.handlers when handlers != nil)
@pkg/warplib/protocol_ftp.go (ftpProtocolDownloader.Resume uses handlers parameter directly for all callbacks)
@internal/server/rpc_methods.go (lines 277-331: downloadResume builds resumeOpts.Handlers, calls ResumeDownload, then go resumedItem.Resume())
@internal/server/rpc_ftp_sftp_notify_test.go (mockProtocolDownloader, newTestRPCHandlerWithRouter — reuse for resume tests)
@internal/server/rpc_resume_notify_test.go (HTTP resume notify tests — regression reference)
@internal/api/resume.go (lines 90-95: resumeItem calls item.Resume() — CLI path, no signature change needed)
</context>

<interfaces>
<!-- Key types and contracts the executor needs. -->

The defect (item.go:282-283 — current code):
```go
// Pass nil handlers — Manager.patchHandlers already installed them on the inner downloader.
return d.Resume(context.Background(), partsCopy, nil)
```
The comment is correct for HTTP (handlers live on *Downloader struct) but WRONG for FTP/SFTP (handlers are the parameter).

httpProtocolDownloader.Resume behavior (protocol_http.go:69-77):
```go
func (h *httpProtocolDownloader) Resume(_ context.Context, parts map[int64]*ItemPart, handlers *Handlers) error {
    if !h.probed || h.inner == nil {
        return ErrProbeRequired
    }
    if handlers != nil {
        h.inner.handlers = handlers  // REPLACES struct field when non-nil
    }
    return h.inner.Resume(parts)
}
```
CRITICAL: passing non-nil handlers to HTTP would BYPASS patchHandlers wrapping. HTTP items MUST keep resumeHandlers = nil.

FTP/SFTP Resume behavior (protocol_ftp.go):
```go
func (d *ftpProtocolDownloader) Resume(ctx context.Context, parts map[int64]*ItemPart, handlers *Handlers) error {
    // uses handlers parameter directly:
    pw := &ftpProgressWriter{handlers: handlers, hash: d.hash}
    // handlers.DownloadCompleteHandler(MAIN_HASH, d.fileSize)
}
```
All callbacks use the `handlers` parameter. Passing nil = zero notifications.

Item struct unexported fields pattern (item.go:57-65):
```go
mu       *sync.RWMutex
dAllocMu sync.RWMutex
dAlloc   ProtocolDownloader
memPart  map[string]int64
```
GOB skips all unexported fields. Adding `resumeHandlers *Handlers` follows this exact pattern.

setDAlloc pattern (item.go:182-186):
```go
func (i *Item) setDAlloc(d ProtocolDownloader) {
    i.dAllocMu.Lock()
    defer i.dAllocMu.Unlock()
    i.dAlloc = d
}
```

ResumeDownload FTP/SFTP branch (manager.go:609-615):
```go
if opts.Handlers == nil {
    opts.Handlers = &Handlers{}
}
m.patchProtocolHandlers(opts.Handlers, item)
item.setDAlloc(pd)
m.UpdateItem(item)
```
NEW line goes between patchProtocolHandlers and setDAlloc.

downloadResume caller (rpc_methods.go:329):
```go
go resumedItem.Resume()
```
No change needed here — Item.Resume() reads stored handlers internally.

resumeItem CLI caller (api/resume.go:90-95):
```go
func resumeItem(i *warplib.Item) error {
    if i.Downloaded >= i.TotalSize {
        return nil
    }
    return i.Resume()
}
```
No change needed — resumeHandlers stays nil for CLI path, Item.Resume() passes nil, which is correct for HTTP.

Existing mockProtocolDownloader.Resume (rpc_ftp_sftp_notify_test.go:61-63):
```go
func (m *mockProtocolDownloader) Resume(_ context.Context, _ map[int64]*warplib.ItemPart, _ *warplib.Handlers) error {
    return nil
}
```
Must be updated to invoke handler callbacks and signal completion (same pattern as Download method).
</interfaces>

<feature>
  <name>RPC FTP/SFTP Resume Handler Pass-Through Fix with TDD</name>
  <files>pkg/warplib/item.go, pkg/warplib/manager.go, internal/server/rpc_ftp_sftp_notify_test.go, internal/server/rpc_ftp_sftp_resume_test.go</files>
  <behavior>
    Task 1 (RED) — Write failing tests FIRST:

    A. Update mockProtocolDownloader.Resume in rpc_ftp_sftp_notify_test.go to actually invoke handler callbacks (mirroring the Download method pattern):
    ```go
    func (m *mockProtocolDownloader) Resume(_ context.Context, _ map[int64]*warplib.ItemPart, h *warplib.Handlers) error {
        if !m.probed {
            return warplib.ErrProbeRequired
        }
        if h != nil {
            if h.DownloadProgressHandler != nil {
                atomic.AddInt32(&m.progressCalled, 1)
                h.DownloadProgressHandler(m.hash, 512)
            }
            if h.DownloadCompleteHandler != nil {
                atomic.AddInt32(&m.completeCalled, 1)
                h.DownloadCompleteHandler(warplib.MAIN_HASH, m.contentLength)
            }
        }
        close(m.doneCh)
        return nil
    }
    ```
    CRITICAL: Must use warplib.MAIN_HASH in DownloadCompleteHandler call — patchProtocolHandlers only finalizes item when hash == MAIN_HASH.
    CRITICAL: doneCh must be buffered(1) to avoid blocking.

    B. Create internal/server/rpc_ftp_sftp_resume_test.go with 2 test functions:

    - TestRPCDownloadResume_FTP_HandlersFired: Tests that resuming an FTP download via RPC fires handler callbacks. Flow:
      1. Register mock for "ftp" scheme
      2. Call download.add with ftp:// URL, wait for mock.Download to complete (doneCh)
      3. Reset mock counters (progressCalled=0, completeCalled=0), create new buffered doneCh
      4. Call download.pause (sets dAlloc=nil)
      5. Call download.resume (creates new downloader via SchemeRouter, patches handlers, calls go item.Resume())
      6. Wait on new doneCh with 5s deadline
      7. Assert atomic.LoadInt32(mock.progressCalled) > 0
      8. Assert atomic.LoadInt32(mock.completeCalled) > 0

    - TestRPCDownloadResume_SFTP_HandlersFired: Same pattern but for "sftp" scheme with sftp://user:pass@host URL

    Tests MUST FAIL before the production fix because Item.Resume() passes nil handlers to d.Resume().

    Task 2 (GREEN) — Apply production fix:

    Step 1: Add unexported field to Item struct in item.go (after memPart line 65):
    ```go
    // resumeHandlers holds patched handler callbacks for the protocol resume path.
    // Set by Manager.ResumeDownload for FTP/FTPS/SFTP after patchProtocolHandlers.
    // Unexported to prevent GOB serialization (func values cannot be GOB-encoded).
    // nil for HTTP items — HTTP uses patchHandlers on *Downloader struct field.
    resumeHandlers *Handlers
    ```

    Step 2: Add setResumeHandlers and getResumeHandlers methods to item.go (after setDAlloc, ~line 186):
    ```go
    // setResumeHandlers stores patched handlers for use during Resume.
    // Called by Manager.ResumeDownload after patchProtocolHandlers for FTP/SFTP items.
    func (i *Item) setResumeHandlers(h *Handlers) {
        i.dAllocMu.Lock()
        defer i.dAllocMu.Unlock()
        i.resumeHandlers = h
    }
    ```

    Step 3: Update Item.Resume() to read stored handlers (item.go:274-283):
    ```go
    // Then get downloader and resume handlers under dAllocMu lock
    i.dAllocMu.RLock()
    d := i.dAlloc
    h := i.resumeHandlers
    i.dAllocMu.RUnlock()

    if d == nil {
        return ErrItemDownloaderNotFound
    }
    // h is non-nil for FTP/SFTP (set by Manager.ResumeDownload), nil for HTTP.
    // FTP/SFTP Resume uses h parameter directly; HTTP Resume ignores nil (uses struct field).
    return d.Resume(context.Background(), partsCopy, h)
    ```

    Step 4: Add one line in manager.go ResumeDownload FTP/SFTP branch (after line 613):
    ```go
    m.patchProtocolHandlers(opts.Handlers, item)
    item.setResumeHandlers(opts.Handlers)   // Store for Item.Resume() pass-through
    item.setDAlloc(pd)
    ```

    All tests must pass after these changes.

    Task 3 (GATE) — Full suite + coverage verification.
  </behavior>
  <implementation>
    Strict TDD red-green-refactor. Task 1 writes failing tests. Task 2 applies the production fix. Task 3 gates.

    ANTI-PATTERNS TO AVOID:
    - Do NOT call setResumeHandlers for HTTP items — httpProtocolDownloader.Resume replaces h.inner.handlers when non-nil, bypassing patchHandlers wrapping
    - Do NOT call patchProtocolHandlers again inside Item.Resume() — double-patching wraps handlers twice causing infinite recursion
    - Do NOT add an exported field to Item — GOB would try to encode func values and panic
    - Do NOT change Item.Resume() signature — unnecessary; stored field approach avoids caller updates
  </implementation>
</feature>

<task type="auto">
  <name>Task 1: Write failing tests for FTP/SFTP handler wiring in RPC downloadResume (RED)</name>
  <files>internal/server/rpc_ftp_sftp_notify_test.go, internal/server/rpc_ftp_sftp_resume_test.go</files>
  <action>
**Step 1: Update mockProtocolDownloader.Resume in rpc_ftp_sftp_notify_test.go.**

Replace the current no-op Resume method:
```go
func (m *mockProtocolDownloader) Resume(_ context.Context, _ map[int64]*warplib.ItemPart, _ *warplib.Handlers) error {
    return nil
}
```

With a version that invokes handler callbacks (same pattern as Download):
```go
func (m *mockProtocolDownloader) Resume(_ context.Context, _ map[int64]*warplib.ItemPart, h *warplib.Handlers) error {
    if !m.probed {
        return warplib.ErrProbeRequired
    }
    if h != nil {
        if h.DownloadProgressHandler != nil {
            atomic.AddInt32(&m.progressCalled, 1)
            h.DownloadProgressHandler(m.hash, 512)
        }
        if h.DownloadCompleteHandler != nil {
            atomic.AddInt32(&m.completeCalled, 1)
            h.DownloadCompleteHandler(warplib.MAIN_HASH, m.contentLength)
        }
    }
    if m.doneCh != nil {
        select {
        case <-m.doneCh:
            // Already closed
        default:
            close(m.doneCh)
        }
    }
    return nil
}
```

NOTE: The Resume mock must use a safe close pattern because doneCh may have already been closed by Download. Use select to check before closing. Alternatively, the test can create a fresh doneCh between download and resume phases.

IMPORTANT: Verify existing tests still pass after this change:
```bash
go test -run "TestRPCDownloadAdd_FTP|TestRPCDownloadAdd_SFTP" ./internal/server/ -v -count=1
```
The existing download.add tests should still pass because they only exercise Download, not Resume.

**Step 2: Create internal/server/rpc_ftp_sftp_resume_test.go.**

```go
package server

import (
    "net/http"
    "sync/atomic"
    "testing"
    "time"

    "github.com/warpdl/warpdl/pkg/warplib"
)

// TestRPCDownloadResume_FTP_HandlersFired verifies that FTP downloads
// resumed via RPC download.resume invoke handler callbacks (progress/complete).
func TestRPCDownloadResume_FTP_HandlersFired(t *testing.T) {
    router := warplib.NewSchemeRouter(http.DefaultClient)
    var mock *mockProtocolDownloader

    // Register a mock factory for "ftp" scheme.
    // The factory is called TWICE: once for download.add, once for download.resume
    // (ResumeDownload creates a new ProtocolDownloader via SchemeRouter).
    router.Register("ftp", func(rawURL string, opts *warplib.DownloaderOpts) (warplib.ProtocolDownloader, error) {
        dlDir := opts.DownloadDirectory
        if dlDir == "" {
            dlDir = t.TempDir()
        }
        mock = &mockProtocolDownloader{
            hash:          "test-ftp-resume",
            fileName:      "resume.bin",
            downloadDir:   dlDir,
            contentLength: 2048,
            doneCh:        make(chan struct{}, 1),
        }
        return mock, nil
    })

    handler, secret, cleanup, m, dlDir := newTestRPCHandlerWithRouter(t, router)
    defer cleanup()

    // Phase 1: Add an FTP download and wait for it to complete.
    code, resp := rpcCall(t, handler, "download.add", map[string]any{
        "url": "ftp://example.com/resume.bin",
        "dir": dlDir,
    }, secret)
    if code != http.StatusOK {
        t.Fatalf("download.add: expected 200, got %d", code)
    }
    result := rpcResult(t, resp)
    gid, ok := result["gid"].(string)
    if !ok || gid == "" {
        t.Fatalf("expected non-empty gid, got %v", result["gid"])
    }

    // Wait for initial download to complete.
    select {
    case <-mock.doneCh:
    case <-time.After(5 * time.Second):
        t.Fatal("timeout waiting for initial download to complete")
    }

    // Phase 2: Pause the download.
    code, resp = rpcCall(t, handler, "download.pause", map[string]any{
        "gid": gid,
    }, secret)
    if code != http.StatusOK {
        t.Fatalf("download.pause: expected 200, got %d", code)
    }

    // Phase 3: Resume the download.
    // The factory will be called again, creating a fresh mock.
    // Reset counters happen automatically because a new mock is created.
    code, resp = rpcCall(t, handler, "download.resume", map[string]any{
        "gid": gid,
    }, secret)
    if code != http.StatusOK {
        t.Fatalf("download.resume: expected 200, got %d; resp=%v", code, resp)
    }

    // Wait for resume to complete via the NEW mock's doneCh.
    select {
    case <-mock.doneCh:
    case <-time.After(5 * time.Second):
        t.Fatal("timeout waiting for resumed download to complete")
    }

    // Assert handler callbacks were invoked during resume.
    if pc := atomic.LoadInt32(&mock.progressCalled); pc <= 0 {
        t.Fatalf("expected progressCalled > 0, got %d — DownloadProgressHandler NOT invoked during resume", pc)
    }
    if cc := atomic.LoadInt32(&mock.completeCalled); cc <= 0 {
        t.Fatalf("expected completeCalled > 0, got %d — DownloadCompleteHandler NOT invoked during resume", cc)
    }

    // Verify item state updated.
    item := m.GetItem(gid)
    if item == nil {
        t.Fatal("item not found in manager after resume")
    }
    if item.GetDownloaded() <= 0 {
        t.Fatalf("expected Downloaded > 0 after resume, got %d", item.GetDownloaded())
    }
}

// TestRPCDownloadResume_SFTP_HandlersFired verifies that SFTP downloads
// resumed via RPC download.resume invoke handler callbacks.
func TestRPCDownloadResume_SFTP_HandlersFired(t *testing.T) {
    router := warplib.NewSchemeRouter(http.DefaultClient)
    var mock *mockProtocolDownloader

    router.Register("sftp", func(rawURL string, opts *warplib.DownloaderOpts) (warplib.ProtocolDownloader, error) {
        dlDir := opts.DownloadDirectory
        if dlDir == "" {
            dlDir = t.TempDir()
        }
        mock = &mockProtocolDownloader{
            hash:          "test-sftp-resume",
            fileName:      "resume-sftp.bin",
            downloadDir:   dlDir,
            contentLength: 4096,
            doneCh:        make(chan struct{}, 1),
        }
        return mock, nil
    })

    handler, secret, cleanup, m, dlDir := newTestRPCHandlerWithRouter(t, router)
    defer cleanup()

    // Phase 1: Add an SFTP download and wait for it to complete.
    code, resp := rpcCall(t, handler, "download.add", map[string]any{
        "url": "sftp://user:pass@example.com/resume-sftp.bin",
        "dir": dlDir,
    }, secret)
    if code != http.StatusOK {
        t.Fatalf("download.add: expected 200, got %d", code)
    }
    result := rpcResult(t, resp)
    gid, ok := result["gid"].(string)
    if !ok || gid == "" {
        t.Fatalf("expected non-empty gid, got %v", result["gid"])
    }

    select {
    case <-mock.doneCh:
    case <-time.After(5 * time.Second):
        t.Fatal("timeout waiting for initial SFTP download to complete")
    }

    // Phase 2: Pause.
    code, resp = rpcCall(t, handler, "download.pause", map[string]any{
        "gid": gid,
    }, secret)
    if code != http.StatusOK {
        t.Fatalf("download.pause: expected 200, got %d", code)
    }

    // Phase 3: Resume.
    code, resp = rpcCall(t, handler, "download.resume", map[string]any{
        "gid": gid,
    }, secret)
    if code != http.StatusOK {
        t.Fatalf("download.resume: expected 200, got %d; resp=%v", code, resp)
    }

    select {
    case <-mock.doneCh:
    case <-time.After(5 * time.Second):
        t.Fatal("timeout waiting for resumed SFTP download to complete")
    }

    if pc := atomic.LoadInt32(&mock.progressCalled); pc <= 0 {
        t.Fatalf("expected progressCalled > 0, got %d — DownloadProgressHandler NOT invoked during SFTP resume", pc)
    }
    if cc := atomic.LoadInt32(&mock.completeCalled); cc <= 0 {
        t.Fatalf("expected completeCalled > 0, got %d — DownloadCompleteHandler NOT invoked during SFTP resume", cc)
    }

    item := m.GetItem(gid)
    if item == nil {
        t.Fatal("item not found in manager after SFTP resume")
    }
    if item.GetDownloaded() <= 0 {
        t.Fatalf("expected Downloaded > 0 after SFTP resume, got %d", item.GetDownloaded())
    }
}
```

**Step 3: Verify tests FAIL (RED).**

```bash
go test -run "TestRPCDownloadResume_FTP_HandlersFired|TestRPCDownloadResume_SFTP_HandlersFired" ./internal/server/ -v -count=1
```

Tests MUST fail because Item.Resume() passes nil to d.Resume(), so the mock's Resume method receives nil handlers and progressCalled/completeCalled stay 0.

If tests pass before the fix, the mock or test logic is wrong. Investigate.

**Step 4: Verify existing tests still pass.**

```bash
go test -run "TestRPCDownloadAdd_FTP|TestRPCDownloadAdd_SFTP" ./internal/server/ -v -count=1
```

Existing download.add tests must still pass (the mock Resume change doesn't affect Download).
  </action>
  <verify>
    <automated>go test -run "TestRPCDownloadResume_FTP_HandlersFired|TestRPCDownloadResume_SFTP_HandlersFired" ./internal/server/ -v -count=1 2>&1 | grep -c FAIL</automated>
    New resume tests must FAIL (RED phase). At least 1 FAIL line expected.
    <automated>go test -run "TestRPCDownloadAdd_FTP|TestRPCDownloadAdd_SFTP" ./internal/server/ -v -count=1</automated>
    Existing download.add tests must still PASS (no regression from mock change).
  </verify>
  <done>
- Updated mockProtocolDownloader.Resume in rpc_ftp_sftp_notify_test.go invokes handler callbacks
- New file `internal/server/rpc_ftp_sftp_resume_test.go` exists with 2 test functions
- TestRPCDownloadResume_FTP_HandlersFired and TestRPCDownloadResume_SFTP_HandlersFired compile
- New resume tests fail because nil handlers in Item.Resume() prevent mock callbacks from firing
- Existing download.add tests still pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Add resumeHandlers field to Item and wire through manager (GREEN)</name>
  <files>pkg/warplib/item.go, pkg/warplib/manager.go</files>
  <action>
**Step 1: Add unexported `resumeHandlers` field to Item struct in item.go.**

After line 65 (`memPart map[string]int64`), before the closing brace of the Item struct:
```go
// resumeHandlers holds patched handler callbacks for the protocol resume path.
// Set by Manager.ResumeDownload for FTP/FTPS/SFTP after patchProtocolHandlers.
// Unexported to prevent GOB serialization (func values cannot be GOB-encoded).
// nil for HTTP items — HTTP uses patchHandlers on *Downloader struct field.
resumeHandlers *Handlers
```

**Step 2: Add setResumeHandlers method to item.go.**

After the setDAlloc method (~line 186), add:
```go
// setResumeHandlers stores patched handlers for use during Item.Resume().
// Called by Manager.ResumeDownload after patchProtocolHandlers for FTP/FTPS/SFTP items.
func (i *Item) setResumeHandlers(h *Handlers) {
    i.dAllocMu.Lock()
    defer i.dAllocMu.Unlock()
    i.resumeHandlers = h
}
```

**Step 3: Update Item.Resume() to read stored handlers.**

In the Resume method, change the dAllocMu read section and the return statement.

Current code (lines 274-283):
```go
// Then get downloader under dAllocMu lock
i.dAllocMu.RLock()
d := i.dAlloc
i.dAllocMu.RUnlock()

if d == nil {
    return ErrItemDownloaderNotFound
}
// Pass nil handlers — Manager.patchHandlers already installed them on the inner downloader.
return d.Resume(context.Background(), partsCopy, nil)
```

Replace with:
```go
// Then get downloader and resume handlers under dAllocMu lock
i.dAllocMu.RLock()
d := i.dAlloc
h := i.resumeHandlers
i.dAllocMu.RUnlock()

if d == nil {
    return ErrItemDownloaderNotFound
}
// h is non-nil for FTP/SFTP (set by Manager.ResumeDownload), nil for HTTP.
// FTP/SFTP Resume uses h parameter directly for callbacks.
// HTTP Resume: nil preserves patchHandlers-installed struct field (non-nil would replace it).
return d.Resume(context.Background(), partsCopy, h)
```

Also update the Resume method comment at line 262-264:
```go
// Resume resumes the download of the item.
// Fixed Race 2: Takes snapshot of Parts under Item lock before calling Resume.
// For FTP/SFTP: passes stored resumeHandlers to ProtocolDownloader.Resume().
// For HTTP: resumeHandlers is nil, preserving patchHandlers-installed struct field handlers.
```

**Step 4: Add one line in manager.go ResumeDownload FTP/SFTP branch.**

In manager.go, after `m.patchProtocolHandlers(opts.Handlers, item)` (line 613) and before `item.setDAlloc(pd)` (line 614), add:
```go
item.setResumeHandlers(opts.Handlers)
```

So lines 613-615 become:
```go
m.patchProtocolHandlers(opts.Handlers, item)
item.setResumeHandlers(opts.Handlers)
item.setDAlloc(pd)
```

**Step 5: Verify compilation.**

```bash
go vet ./pkg/warplib/... ./internal/server/...
go build ./...
```

**Step 6: Run tests (GREEN).**

```bash
go test -run "TestRPCDownloadResume_FTP_HandlersFired|TestRPCDownloadResume_SFTP_HandlersFired" ./internal/server/ -race -v -count=1
```

Both tests must now PASS.

**Step 7: Verify HTTP resume is unaffected (no regression).**

```bash
go test -run "TestRPCDownloadResume" ./internal/server/ -race -v -count=1
```

All existing resume tests (TestRPCDownloadResume_BroadcastsStarted, TestRPCDownloadResume_NilNotifier, TestRPCDownloadResume_HandlerWiring) must still pass.

**Step 8: Verify existing download.add tests still pass.**

```bash
go test -run "TestRPCDownloadAdd" ./internal/server/ -race -v -count=1
```
  </action>
  <verify>
    <automated>go test -run "TestRPCDownloadResume_FTP_HandlersFired|TestRPCDownloadResume_SFTP_HandlersFired" ./internal/server/ -race -v -count=1</automated>
    Both new resume tests must PASS (GREEN phase).
    <automated>go test -run "TestRPCDownloadResume" ./internal/server/ -race -v -count=1</automated>
    All resume tests (existing + new) must pass — no HTTP regression.
    <automated>go test -run "TestRPCDownloadAdd" ./internal/server/ -race -v -count=1</automated>
    Existing download.add tests must still pass.
  </verify>
  <done>
- Item struct has unexported `resumeHandlers *Handlers` field (GOB-safe)
- `setResumeHandlers` method added to Item
- `Item.Resume()` reads `resumeHandlers` under dAllocMu and passes to `d.Resume()`
- `manager.go` ResumeDownload FTP/SFTP branch calls `item.setResumeHandlers(opts.Handlers)` after patchProtocolHandlers
- HTTP resume path unaffected (resumeHandlers stays nil for HTTP items)
- All resume tests pass with `-race` flag
- All download.add tests still pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Run full suite and coverage gate</name>
  <files></files>
  <action>
Run the complete test suite with race detection and verify coverage thresholds.

**Step 1: Full project tests.**
```bash
go test -race -short ./...
```
Must pass with zero failures.

**Step 2: Server package coverage.**
```bash
go test -cover ./internal/server/...
```
Must be >= 80%.

**Step 3: Warplib package coverage.**
```bash
go test -cover ./pkg/warplib/...
```
Must be >= 80%.

**Step 4: Formatting and vet.**
```bash
go vet ./...
go fmt ./...
```
Must report no issues and no formatting changes.

**Step 5: Verify the nil at line 283 is gone.**
```bash
grep -n 'partsCopy, nil' pkg/warplib/item.go
```
Must return zero matches. The nil should now be replaced with `h`.

**Step 6: Verify setResumeHandlers is called only in FTP/SFTP branch.**
```bash
grep -n 'setResumeHandlers' pkg/warplib/manager.go
```
Must appear exactly once, inside the `case ProtoFTP, ProtoFTPS, ProtoSFTP:` branch.

**Step 7: Verify resumeHandlers is unexported (GOB-safe).**
```bash
grep -n 'resumeHandlers' pkg/warplib/item.go
```
Confirm the field name starts with lowercase `r` (unexported).
  </action>
  <verify>
    <automated>go test -race -short ./... && go test -cover ./internal/server/... && go test -cover ./pkg/warplib/... && go vet ./...</automated>
  </verify>
  <done>
- Zero test failures across entire project with `-race -short`
- Server package coverage >= 80%
- Warplib package coverage >= 80%
- No vet warnings
- Code properly formatted
- `partsCopy, nil` no longer appears in item.go Resume method
- `setResumeHandlers` called only in FTP/SFTP branch of ResumeDownload
- `resumeHandlers` field is unexported (GOB-safe)
  </done>
</task>

<verification>
```bash
cd /Users/divkix/GitHub/warpdl/.claude/worktrees/issues-fix

# Per-task: new resume tests pass with race detection
go test -run "TestRPCDownloadResume_FTP_HandlersFired|TestRPCDownloadResume_SFTP_HandlersFired" ./internal/server/ -race -v -count=1

# All resume tests (existing HTTP + new FTP/SFTP)
go test -run "TestRPCDownloadResume" ./internal/server/ -race -v -count=1

# All download.add tests (no regression)
go test -run "TestRPCDownloadAdd" ./internal/server/ -race -v -count=1

# Full server suite
go test ./internal/server/... -race -count=1

# Full warplib suite
go test ./pkg/warplib/... -race -count=1

# Phase gate
go test -race -short ./...
go test -cover ./internal/server/...
go test -cover ./pkg/warplib/...
go vet ./...
```
</verification>

<success_criteria>
- FTP/SFTP downloads resumed via RPC download.resume emit handler callbacks (proven by atomic counters in mock)
- item.Downloaded is updated during FTP/SFTP RPC resume (proven by item.GetDownloaded() assertion)
- HTTP resume path unaffected — no regression in existing TestRPCDownloadResume_* tests
- Item.resumeHandlers field is unexported (GOB serialization skips it)
- setResumeHandlers called only in FTP/SFTP branch (not HTTP)
- Tests pass with -race flag (no data races)
- Server + warplib package coverage >= 80%
- Zero regressions in full test suite
</success_criteria>

<output>
After completion, create `.planning/phases/09-fix-rpc-ftp-sftp-resume-handlers/09-01-SUMMARY.md`
</output>
