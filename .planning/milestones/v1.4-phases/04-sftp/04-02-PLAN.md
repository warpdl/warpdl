---
phase: 04-sftp
plan: 02
type: tdd
wave: 2
depends_on: [04-01]
files_modified:
  - pkg/warplib/protocol_sftp.go
  - pkg/warplib/protocol_sftp_test.go
  - pkg/warplib/manager.go
autonomous: true
requirements: [SFTP-06]

must_haves:
  truths:
    - "Resume() connects fresh, opens remote file, calls file.Seek(offset, io.SeekStart) to resume from byte offset (SFTP-06)"
    - "Resume() derives start offset from WarpStat(savePath).Size(), not from parts map key (SFTP single-stream: file size on disk is source of truth for resume position)"
    - "Resume() opens destination file with O_WRONLY, seeks to offset, streams from remote file via io.Copy"
    - "Resume() with all parts compiled (fully downloaded) returns nil immediately without connecting"
    - "Resume() without Probe() returns ErrProbeRequired"
    - "Resume() calls handlers.DownloadProgressHandler during streaming and handlers.DownloadCompleteHandler(MAIN_HASH, totalBytes) on success"
    - "Resume() file operations use WarpOpenFile with DefaultFileMode (NOT os.OpenFile with literal 0644) for cross-platform support"
    - "Manager.ResumeDownload handles item.Protocol == ProtoSFTP by creating SFTP downloader via SchemeRouter and calling Resume"
    - "Manager.ResumeDownload with item.Protocol==ProtoSFTP skips validateDownloadIntegrity (SFTP has no segment files); instead checks destination file exists if Downloaded > 0"
    - "Manager.ResumeDownload with item.Protocol==ProtoHTTP still uses initDownloader path (zero regression)"
    - "Manager has schemeRouter field already set (from Phase 3) -- ProtoSFTP case added alongside ProtoFTP/ProtoFTPS"
    - "SFTP resume integration test: partial download interrupted, resumed from offset, final file matches expected content"
    - "User-observable: An interrupted SFTP download can be resumed from the CLI and completes to the correct final file without re-downloading already-fetched bytes"
    - "User-observable: Resuming an SFTP download that was already fully completed is a no-op (returns immediately)"
  artifacts:
    - path: "pkg/warplib/protocol_sftp.go"
      provides: "Resume method implementation (replacing stub from 04-01)"
    - path: "pkg/warplib/protocol_sftp_test.go"
      provides: "Resume tests with mock server, Manager.ResumeDownload SFTP path tests"
    - path: "pkg/warplib/manager.go"
      provides: "Updated ResumeDownload protocol guard and dispatch: ProtoSFTP case alongside ProtoFTP/ProtoFTPS"
  key_links:
    - from: "pkg/warplib/protocol_sftp.go:Resume"
      to: "github.com/pkg/sftp:File.Seek"
      via: "Seek(offset, io.SeekStart) positions remote file read at resume offset"
      pattern: "Seek"
    - from: "pkg/warplib/manager.go:ResumeDownload"
      to: "pkg/warplib/protocol_sftp.go:sftpProtocolDownloader"
      via: "SchemeRouter creates SFTP downloader for resume when item.Protocol == ProtoSFTP"
      pattern: "ProtoSFTP"
    - from: "pkg/warplib/manager.go:ResumeDownload"
      to: "pkg/warplib/integrity.go:validateDownloadIntegrity"
      via: "EXISTING function -- called ONLY for ProtoHTTP items. SFTP items skip it. DO NOT reimplement."
      pattern: "validateDownloadIntegrity"
---

<objective>
Add SFTP resume via Seek offset, and wire Manager.ResumeDownload for SFTP protocol items.

Purpose: Plan 04-01 delivers fresh SFTP downloads. This plan completes the SFTP story with resume-after-interruption (SFTP-06). It also wires `Manager.ResumeDownload` to dispatch ProtoSFTP items through `SchemeRouter` alongside the existing ProtoFTP/ProtoFTPS cases, making resume work for SFTP items stored in `userdata.warp`.

Output: Resume() method in protocol_sftp.go (replacing stub), Manager.ResumeDownload SFTP dispatch, and comprehensive tests.
</objective>

<execution_context>
@/Users/divkix/.claude/get-shit-done/workflows/execute-plan.md
@/Users/divkix/.claude/get-shit-done/templates/summary.md
@/Users/divkix/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/04-sftp/04-RESEARCH.md
@.planning/phases/04-sftp/04-01-PLAN.md

@pkg/warplib/protocol_sftp.go      (created by Plan 04-01)
@pkg/warplib/protocol_sftp_test.go  (created by Plan 04-01)
@pkg/warplib/known_hosts.go         (created by Plan 04-01)
@pkg/warplib/protocol.go
@pkg/warplib/protocol_router.go
@pkg/warplib/manager.go
@pkg/warplib/item.go
@pkg/warplib/handlers.go
</context>

<interfaces>
<!-- Key types and contracts the executor needs. -->

From pkg/warplib/protocol_sftp.go (created by Plan 04-01):
```go
type sftpProtocolDownloader struct {
    rawURL     string
    opts       *DownloaderOpts
    host       string
    remotePath string
    user       string
    password   string
    sshKeyPath string
    fileName   string
    fileSize   int64
    hash       string
    dlDir      string
    savePath   string
    probed     bool
    stopped    int32
    cleanURL   string
    ctx        context.Context
    cancel     context.CancelFunc
}

func (d *sftpProtocolDownloader) connect(ctx context.Context) (*ssh.Client, *sftp.Client, error) {
    // Established in 04-01: builds auth methods, creates TOFU callback, dials SSH, opens SFTP
}

func (d *sftpProtocolDownloader) Resume(ctx context.Context, parts map[int64]*ItemPart, handlers *Handlers) error {
    // STUB from Plan 04-01 -- must be implemented here
}
```

From github.com/pkg/sftp v1.13.10:
```go
func (f *File) Seek(offset int64, whence int) (int64, error)
// Uses io.SeekStart (0) for resume offset positioning
```

From pkg/warplib/manager.go -- current ResumeDownload (FTP cases already present from Phase 3):
```go
func (m *Manager) ResumeDownload(client *http.Client, hash string, opts *ResumeDownloadOpts) (item *Item, err error) {
    // Protocol guard switch:
    //   case ProtoHTTP: validateDownloadIntegrity (existing)
    //   case ProtoFTP, ProtoFTPS: check dest file exists if Downloaded > 0 (Phase 3)
    //   default: "resume not supported for protocol"
    // Must add: case ProtoSFTP alongside ProtoFTP, ProtoFTPS

    // Dispatch switch:
    //   case ProtoFTP, ProtoFTPS: SchemeRouter.NewDownloader -> Probe -> patchProtocolHandlers -> setDAlloc (Phase 3)
    //   default: initDownloader -> patchHandlers -> httpProtocolDownloader adapter (existing HTTP)
    // Must add: case ProtoSFTP alongside ProtoFTP, ProtoFTPS
}
```

From pkg/warplib/item.go -- Resume flow:
```go
func (i *Item) Resume() error {
    // Snapshots Parts, gets dAlloc, calls d.Resume(context.Background(), partsCopy, nil)
    // NOTE: passes nil handlers because patchProtocolHandlers already installed them
}
```
</interfaces>

<feature>
  <name>SFTP Resume and Manager ResumeDownload SFTP Dispatch</name>
  <files>pkg/warplib/protocol_sftp.go, pkg/warplib/protocol_sftp_test.go, pkg/warplib/manager.go</files>
  <behavior>
    Test cases for SFTP-06 (resume via Seek offset):
    1. Resume() with single uncompiled part: connects, opens remote file, Seek(offset), streams remaining bytes to local file at offset
    2. Resume() opens destination file, seeks to offset, writes remaining -- final file matches expected content
    3. Resume() with all parts compiled returns nil without connecting (no-op for complete download)
    4. Resume() without Probe() returns ErrProbeRequired
    5. Resume() calls DownloadProgressHandler during streaming
    6. Resume() calls DownloadCompleteHandler(MAIN_HASH, totalBytes) on success
    7. Resume() when destination file does not exist (startOffset=0): starts fresh download from beginning

    Integration: SFTP resume end-to-end:
    8. Start fresh SFTP download against mock server (1024 bytes)
    9. Interrupt after 512 bytes (simulate by creating partial file)
    10. Call Resume with the partial state -- file completed from offset 512
    11. Final file content matches full expected content (first 512 bytes original + remaining from server)

    Manager.ResumeDownload for SFTP:
    12. ResumeDownload with item.Protocol==ProtoSFTP creates SFTP downloader via SchemeRouter, not initDownloader
    13. ResumeDownload with item.Protocol==ProtoSFTP calls patchProtocolHandlers (not patchHandlers)
    14. ResumeDownload with item.Protocol==ProtoHTTP still uses initDownloader path (zero regression)
    15. After ResumeDownload for SFTP item, Item.Resume() works correctly

    Protocol guard for validateDownloadIntegrity:
    16. ResumeDownload with item.Protocol==ProtoSFTP does NOT call validateDownloadIntegrity
    17. ResumeDownload with item.Protocol==ProtoSFTP and Downloaded>0 but missing destination file returns ErrDownloadDataMissing
    18. ResumeDownload with item.Protocol==ProtoSFTP and Downloaded==0 (never started) succeeds without destination file check
    19. ResumeDownload with item.Protocol==ProtoHTTP and missing segment dir still returns ErrDownloadDataMissing (existing behavior preserved)
  </behavior>
  <implementation>
    PHASE A: RED -- Write failing tests

    Add to pkg/warplib/protocol_sftp_test.go:
    ```go
    func TestSFTPResume(t *testing.T) { /* tests 1-7 */ }
    func TestSFTPResumeIntegration(t *testing.T) { /* tests 8-11 */ }
    func TestResumeDownloadSFTP(t *testing.T) { /* tests 12-15 */ }
    func TestResumeDownloadSFTPIntegrityGuard(t *testing.T) { /* tests 16-19 */ }
    ```

    For the resume integration test (tests 8-11):
    - Start mock SFTP server with a known file (1024 bytes)
    - Manually create a partial file on disk (first 512 bytes of expected content)
    - The resume offset is derived from the partial file's size on disk (512)
    - Resume() checks WarpStat(d.savePath), gets 512, Seek(512) on remote file, reads remaining bytes

    PHASE B: GREEN -- Implement Resume() in protocol_sftp.go

    ```go
    func (d *sftpProtocolDownloader) Resume(ctx context.Context, parts map[int64]*ItemPart, handlers *Handlers) error {
        if !d.probed {
            return ErrProbeRequired
        }

        if atomic.LoadInt32(&d.stopped) == 1 {
            return nil
        }

        // Check if all parts are compiled (download complete)
        allCompiled := true
        for _, part := range parts {
            if part != nil && !part.Compiled {
                allCompiled = false
                break
            }
        }
        if allCompiled && len(parts) > 0 {
            return nil // Nothing to resume
        }

        // Determine resume offset from destination file size
        var startOffset int64
        info, err := WarpStat(d.savePath)
        if err != nil {
            if os.IsNotExist(err) {
                startOffset = 0
            } else {
                return NewPermanentError("sftp", "resume:stat", err)
            }
        } else {
            startOffset = info.Size()
        }

        // If offset >= fileSize, download is complete
        if startOffset >= d.fileSize {
            if handlers != nil && handlers.DownloadCompleteHandler != nil {
                handlers.DownloadCompleteHandler(MAIN_HASH, d.fileSize)
            }
            return nil
        }

        sshConn, sftpClient, err := d.connect(ctx)
        if err != nil {
            return classifySFTPError("sftp", "resume:connect", err)
        }
        defer sshConn.Close()
        defer sftpClient.Close()

        remoteFile, err := sftpClient.Open(d.remotePath)
        if err != nil {
            return classifySFTPError("sftp", "resume:open", err)
        }
        defer remoteFile.Close()

        if startOffset > 0 {
            if _, err := remoteFile.Seek(startOffset, io.SeekStart); err != nil {
                return NewPermanentError("sftp", "resume:seek", err)
            }
        }

        // Open local file for writing at offset
        f, err := WarpOpenFile(d.savePath, os.O_WRONLY|os.O_CREATE, DefaultFileMode)
        if err != nil {
            return NewPermanentError("sftp", "resume:localopen", err)
        }
        defer f.Close()

        if startOffset > 0 {
            if _, err := f.Seek(startOffset, io.SeekStart); err != nil {
                return NewPermanentError("sftp", "resume:localseek", err)
            }
        }

        // Progress-tracking copy
        pw := &sftpProgressWriter{handlers: handlers, hash: d.hash}
        _, err = io.Copy(io.MultiWriter(f, pw), remoteFile)
        if err != nil {
            return classifySFTPError("sftp", "resume:copy", err)
        }

        if handlers != nil && handlers.DownloadCompleteHandler != nil {
            handlers.DownloadCompleteHandler(MAIN_HASH, d.fileSize)
        }
        return nil
    }
    ```

    PHASE C: Update Manager.ResumeDownload for ProtoSFTP

    In pkg/warplib/manager.go, the protocol guard and dispatch switches already have ProtoFTP and ProtoFTPS cases from Phase 3. Add ProtoSFTP alongside them:

    Protocol guard (line ~554):
    ```go
    // BEFORE (Phase 3):
    case ProtoFTP, ProtoFTPS:
    // AFTER (Phase 4):
    case ProtoFTP, ProtoFTPS, ProtoSFTP:
    ```

    Dispatch (line ~576):
    ```go
    // BEFORE (Phase 3):
    case ProtoFTP, ProtoFTPS:
    // AFTER (Phase 4):
    case ProtoFTP, ProtoFTPS, ProtoSFTP:
    ```

    This is a minimal, two-line change. Both the integrity guard and the SchemeRouter dispatch already handle the general pattern. ProtoSFTP just needs to be added to the existing case lists.

    PHASE D: REFACTOR -- Clean up

    - Ensure Resume path for HTTP is completely unchanged (zero regression)
    - Verify Resume path for FTP is completely unchanged (zero regression)
    - Verify ResumeDownload test coverage for HTTP, FTP, and SFTP paths
    - Run full test suite
  </implementation>
</feature>

<verification>
```bash
# Per-task TDD cycle
go test -v -run "TestSFTPResume$" ./pkg/warplib/ -count=1
go test -v -run "TestSFTPResumeIntegration" ./pkg/warplib/ -count=1
go test -v -run "TestResumeDownloadSFTP$" ./pkg/warplib/ -count=1
go test -v -run "TestResumeDownloadSFTPIntegrityGuard" ./pkg/warplib/ -count=1

# All SFTP tests (including 04-01 tests)
go test -v -run "TestSFTP|TestTOFU|TestKnownHosts|TestResumeDownloadSFTP" ./pkg/warplib/ -count=1

# Regression -- ALL existing tests must still pass (especially HTTP and FTP resume)
go test ./pkg/warplib/ -count=1

# Full suite including internal packages
go test ./... -count=1

# Race detection
go test -race -short ./pkg/warplib/

# Coverage check -- must remain >= 80%
go test -cover ./pkg/warplib/

# Vet
go vet ./...
```
</verification>

<success_criteria>
- RED: Failing tests exist for SFTP resume, Manager.ResumeDownload SFTP path
- GREEN: All tests pass after Resume implementation and Manager update
- REFACTOR: Clean code, minimal diff to manager.go (adding ProtoSFTP to existing case lists)
- Resume() uses sftp.File.Seek with correct offset derived from destination file size
- Resume() handles all-compiled parts (no-op) and missing file (start from zero)
- Manager.ResumeDownload dispatches ProtoSFTP items through SchemeRouter (alongside FTP/FTPS)
- Manager.ResumeDownload skips validateDownloadIntegrity for SFTP (same guard as FTP)
- Manager.ResumeDownload for SFTP with Downloaded>0 verifies destination file exists
- Manager.ResumeDownload HTTP path is completely unchanged (zero regression)
- Manager.ResumeDownload FTP/FTPS path is completely unchanged (zero regression)
- Full resume integration: partial file -> resume -> correct final file
- All existing tests pass (pkg/warplib, internal, cmd) -- zero regression
- go vet ./... clean
- Coverage remains >= 80% on pkg/warplib
</success_criteria>

<output>
After completion, create `.planning/phases/04-sftp/04-02-SUMMARY.md`
</output>
