---
phase: 05-json-rpc-20
plan: 04
type: tdd
wave: 4
depends_on: [05-01, 05-02, 05-03]
files_modified:
  - internal/server/rpc_integration_test.go
  - internal/api/api_test.go
autonomous: true
requirements: [RPC-01, RPC-02, RPC-03, RPC-04, RPC-05, RPC-06, RPC-07, RPC-08, RPC-09, RPC-10, RPC-11, RPC-12]

must_haves:
  truths:
    - "End-to-end integration test: start real WebServer with RPC, call download.add via HTTP POST, verify download completes, poll download.status for 'complete'"
    - "End-to-end integration test: connect WebSocket client, receive download.progress notifications in real time as download runs"
    - "Auth enforcement integration test: HTTP POST without token gets 401; WebSocket upgrade without token fails"
    - "Auth enforcement integration test: HTTP POST with wrong token gets 401; WebSocket upgrade with wrong token fails"
    - "Localhost binding integration test: WebServer with listenAll=false binds to 127.0.0.1 (verified via net.Dial to 127.0.0.1:<port>)"
    - "Error codes integration test: invalid JSON returns -32700, unknown method returns -32601, missing params returns -32602"
    - "Full lifecycle test: add download -> poll status (active) -> pause -> poll status (waiting) -> resume -> poll status (active) -> complete -> poll status (complete) -> remove"
    - "WebSocket notification sequence test: connect WS -> add download -> receive download.started -> receive download.progress (at least 1) -> receive download.complete -> verify all notifications have 'gid' field"
    - "download.list integration test: add 2 downloads, one completes; filter by 'active' returns only running, 'complete' returns only completed"
    - "Concurrent downloads test: add 2 downloads via RPC concurrently, both complete, both appear in download.list"
    - "All 12 RPC requirements (RPC-01 through RPC-12) have at least one test that validates the requirement end-to-end"
    - "Coverage check: internal/server package at >= 80%"
    - "Coverage check: scripts/check_coverage.sh passes (all packages at >= 80%)"
    - "Race detection: go test -race -short ./... passes with zero data races"
    - "Build verification: go build -ldflags='-w -s' . succeeds"
    - "Existing CLI tests still pass (cmd/ package with WARPDL_TEST_SKIP_DAEMON=1)"
    - "Existing API tests still pass (internal/api/ package)"
  artifacts:
    - path: "internal/server/rpc_integration_test.go"
      provides: "End-to-end integration tests covering all 12 RPC requirements, lifecycle tests, concurrent download tests, notification sequence tests"
    - path: "internal/api/api_test.go"
      provides: "Any required test updates for changed NewServer/NewApi signatures (if not already handled)"
  key_links:
    - from: "internal/server/rpc_integration_test.go"
      to: "internal/server/web.go:WebServer"
      via: "Integration tests start real WebServer via httptest"
      pattern: "httptest\\.NewServer"
    - from: "internal/server/rpc_integration_test.go"
      to: "github.com/coder/websocket:Dial"
      via: "WebSocket client connects for notification tests"
      pattern: "websocket\\.Dial"
---

<objective>
Add end-to-end integration tests that validate all 12 RPC requirements, ensure coverage gate passes, verify race-free operation, and confirm zero regression across the entire codebase.

Purpose: Plans 05-01 through 05-03 deliver implementation with per-feature unit/integration tests. This plan provides the integration test suite that validates requirement coverage, exercises the full download lifecycle over RPC, tests concurrent operations, and ensures the phase gate (80% coverage, race-free, clean build) is met.

Output: rpc_integration_test.go with comprehensive end-to-end tests, any necessary test fixups for changed signatures, verified CI gate.
</objective>

<execution_context>
@/Users/divkix/.claude/get-shit-done/workflows/execute-plan.md
@/Users/divkix/.claude/get-shit-done/templates/summary.md
@/Users/divkix/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/05-json-rpc-20/05-RESEARCH.md
@.planning/phases/05-json-rpc-20/05-01-PLAN.md
@.planning/phases/05-json-rpc-20/05-02-PLAN.md
@.planning/phases/05-json-rpc-20/05-03-PLAN.md

@internal/server/rpc_methods.go (from 05-01 + 05-02 + 05-03)
@internal/server/rpc_auth.go (from 05-01)
@internal/server/rpc_notify.go (from 05-03)
@internal/server/web.go (from 05-01 + 05-03)
@internal/server/web_test.go
@internal/api/api_test.go
@cmd/daemon_core.go
@scripts/check_coverage.sh
</context>

<interfaces>
<!-- Key types and contracts the executor needs. -->

Integration test pattern -- start real WebServer with RPC:
```go
func startTestRPCServer(t *testing.T) (url string, secret string, cleanup func()) {
    t.Helper()
    base := t.TempDir()
    warplib.SetConfigDir(base)
    m, _ := warplib.InitManager()

    // Create mock HTTP server for download targets
    content := bytes.Repeat([]byte("d"), 4096)
    targetSrv := newRangeServer(content)

    pool := NewPool(log.New(io.Discard, "", 0))
    secret = "integration-test-secret"
    rpcCfg := &RPCConfig{
        Secret:  secret,
        Version: "1.0.0-test",
        Commit:  "test-commit",
        BuildType: "test",
    }
    client := &http.Client{}
    router := warplib.NewSchemeRouter(client)

    ws := NewWebServer(log.New(io.Discard, "", 0), m, pool, 0, rpcCfg, client, router)
    httpSrv := httptest.NewServer(ws.handler())

    return httpSrv.URL, secret, func() {
        httpSrv.Close()
        ws.rpc.Close()
        m.Close()
        targetSrv.Close()
    }
}
```

HTTP RPC call helper:
```go
func httpRPC(t *testing.T, url, secret, method string, params any) map[string]any {
    t.Helper()
    reqBody := map[string]any{
        "jsonrpc": "2.0",
        "method":  method,
        "id":      1,
    }
    if params != nil {
        reqBody["params"] = params
    }
    data, _ := json.Marshal(reqBody)
    req, _ := http.NewRequest("POST", url+"/jsonrpc", bytes.NewReader(data))
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("Authorization", "Bearer "+secret)
    resp, _ := http.DefaultClient.Do(req)
    defer resp.Body.Close()
    var result map[string]any
    json.NewDecoder(resp.Body).Decode(&result)
    return result
}
```

WebSocket connect helper:
```go
func wsConnect(t *testing.T, httpURL, secret string) *cws.Conn {
    t.Helper()
    wsURL := "ws" + strings.TrimPrefix(httpURL, "http") + "/jsonrpc/ws"
    ctx := context.Background()
    headers := http.Header{}
    headers.Set("Authorization", "Bearer "+secret)
    conn, _, err := cws.Dial(ctx, wsURL, &cws.DialOptions{
        HTTPHeader: headers,
    })
    if err != nil {
        t.Fatalf("ws connect: %v", err)
    }
    return conn
}
```

Requirement-to-test mapping:
| Requirement | Test Name | What It Validates |
|-------------|-----------|-------------------|
| RPC-01 | TestIntegration_HTTPEndpoint | POST /jsonrpc returns JSON-RPC 2.0 response |
| RPC-02 | TestIntegration_WebSocketEndpoint | WS /jsonrpc/ws upgrade + method call |
| RPC-03 | TestIntegration_AuthEnforcement | HTTP 401 without token; WS rejection without token |
| RPC-04 | TestIntegration_LocalhostBinding | addr() returns 127.0.0.1:port |
| RPC-05 | TestIntegration_DownloadAdd | download.add starts download, returns GID |
| RPC-06 | TestIntegration_DownloadPauseResume | Pause stops, resume restarts |
| RPC-07 | TestIntegration_DownloadRemove | Remove calls FlushOne |
| RPC-08 | TestIntegration_DownloadStatus | Status returns correct fields |
| RPC-09 | TestIntegration_DownloadList | List filters by state |
| RPC-10 | TestIntegration_SystemGetVersion | Version matches server config |
| RPC-11 | TestIntegration_WebSocketNotifications | WS client receives push notifications |
| RPC-12 | TestIntegration_ErrorCodes | -32700, -32601, -32602, -32001 |
</interfaces>

<feature>
  <name>End-to-End Integration Tests and Phase Gate Verification</name>
  <files>internal/server/rpc_integration_test.go, internal/api/api_test.go</files>
  <behavior>
    Integration tests -- one per requirement:
    1. TestIntegration_HTTPEndpoint: POST valid JSON-RPC to /jsonrpc with auth, verify response format (RPC-01)
    2. TestIntegration_WebSocketEndpoint: Connect WS with auth, send method call, receive response (RPC-02)
    3. TestIntegration_AuthEnforcement_HTTP: POST without token -> 401; wrong token -> 401; correct token -> 200 (RPC-03)
    4. TestIntegration_AuthEnforcement_WS: WS upgrade without token -> fail; wrong token -> fail; correct -> succeed (RPC-03)
    5. TestIntegration_LocalhostBinding: WebServer with listenAll=false binds 127.0.0.1 (RPC-04)
    6. TestIntegration_DownloadAdd: Add download via RPC, verify GID returned, download eventually completes (RPC-05)
    7. TestIntegration_DownloadPauseResume: Add -> pause -> verify stopped -> resume -> verify running (RPC-06)
    8. TestIntegration_DownloadRemove: Add download -> remove via RPC -> verify gone from manager (RPC-07)
    9. TestIntegration_DownloadStatus: Add download -> poll status -> verify fields (gid, status, totalLength, completedLength) (RPC-08)
    10. TestIntegration_DownloadList: Add 2 downloads -> one completes -> filter by status returns correct subsets (RPC-09)
    11. TestIntegration_SystemGetVersion: Call system.getVersion -> verify version/commit/buildType (RPC-10)
    12. TestIntegration_WebSocketNotifications: Connect WS -> add download -> collect notifications -> verify download.started and download.complete received (RPC-11)
    13. TestIntegration_ErrorCodes: Invalid JSON -> -32700; unknown method -> -32601; missing param -> -32602; unknown GID -> -32001 (RPC-12)

    Lifecycle tests:
    14. TestIntegration_FullLifecycle: add -> status(active) -> pause -> status(waiting) -> resume -> status(active) -> wait for complete -> status(complete) -> remove -> status returns -32001
    15. TestIntegration_ConcurrentDownloads: Add 2 downloads concurrently, both complete, list returns both

    Gate checks:
    16. Build compiles: go build -ldflags='-w -s' .
    17. Coverage gate: scripts/check_coverage.sh passes
    18. Race detection: go test -race -short ./... passes
    19. go vet ./... clean
    20. Existing cmd/ tests pass with WARPDL_TEST_SKIP_DAEMON=1
    21. Existing api/ tests pass
  </behavior>
  <implementation>
    PHASE A: Create test helpers in rpc_integration_test.go

    ```go
    package server

    import (
        "bytes"
        "context"
        "encoding/json"
        "io"
        "log"
        "net/http"
        "net/http/httptest"
        "strings"
        "testing"
        "time"

        cws "github.com/coder/websocket"
        "github.com/warpdl/warpdl/pkg/warplib"
    )

    const testSecret = "integration-test-secret-42"

    // startIntegrationServer starts a WebServer with RPC and a mock download target.
    func startIntegrationServer(t *testing.T) (serverURL string, targetURL string, cleanup func()) {
        t.Helper()
        base := t.TempDir()
        if err := warplib.SetConfigDir(base); err != nil {
            t.Fatalf("SetConfigDir: %v", err)
        }
        m, err := warplib.InitManager()
        if err != nil {
            t.Fatalf("InitManager: %v", err)
        }

        content := bytes.Repeat([]byte("integration"), 1024) // 11KB file
        targetSrv := newRangeServer(content)

        pool := NewPool(log.New(io.Discard, "", 0))
        client := &http.Client{}
        router := warplib.NewSchemeRouter(client)

        rpcCfg := &RPCConfig{
            Secret:    testSecret,
            Version:   "1.0.0-test",
            Commit:    "abc123",
            BuildType: "integration",
        }

        ws := NewWebServer(log.New(io.Discard, "", 0), m, pool, 0, rpcCfg, client, router)
        httpSrv := httptest.NewServer(ws.handler())

        return httpSrv.URL, targetSrv.URL, func() {
            httpSrv.Close()
            if ws.rpc != nil {
                ws.rpc.Close()
            }
            m.Close()
            targetSrv.Close()
        }
    }

    // rpcPost sends JSON-RPC request via HTTP POST and returns parsed response.
    func rpcPost(t *testing.T, serverURL, method string, params any) (statusCode int, result map[string]any) {
        // ... marshal, send with auth, parse response ...
    }

    // rpcPostNoAuth sends JSON-RPC request without auth token.
    func rpcPostNoAuth(t *testing.T, serverURL, method string, params any) int {
        // ... returns HTTP status code ...
    }

    // wsConnect connects a WebSocket client with auth.
    func wsConnectTest(t *testing.T, serverURL string) *cws.Conn {
        // ... dial with Authorization header ...
    }

    // waitForStatus polls download.status until the expected status is reached or timeout.
    func waitForStatus(t *testing.T, serverURL, gid, expectedStatus string, timeout time.Duration) {
        // ... poll loop with 50ms intervals ...
    }
    ```

    PHASE B: Write integration tests for each requirement

    Each test follows the pattern:
    1. startIntegrationServer
    2. Execute RPC calls
    3. Assert expected behavior
    4. Cleanup

    RPC-01: TestIntegration_HTTPEndpoint
    - POST valid JSON-RPC, check "jsonrpc":"2.0" and "id" match in response

    RPC-02: TestIntegration_WebSocketEndpoint
    - Connect WS, send system.getVersion, read response, verify "result" key

    RPC-03: TestIntegration_AuthEnforcement_HTTP + TestIntegration_AuthEnforcement_WS
    - HTTP: no auth -> 401, wrong auth -> 401, correct auth -> 200
    - WS: no auth -> Dial fails, correct auth -> Dial succeeds

    RPC-04: TestIntegration_LocalhostBinding
    - Check addr() returns 127.0.0.1 prefix (unit-level, already in 05-01, but verify here too)

    RPC-05: TestIntegration_DownloadAdd
    - download.add with targetURL, get GID, verify manager has item

    RPC-06: TestIntegration_DownloadPauseResume
    - Add download -> pause -> check not in pool -> resume -> check in pool

    RPC-07: TestIntegration_DownloadRemove
    - Add download (small file, will complete) -> wait for complete -> remove -> status returns -32001

    RPC-08: TestIntegration_DownloadStatus
    - Add download -> poll status -> verify all fields present and non-zero totalLength

    RPC-09: TestIntegration_DownloadList
    - Add 2 downloads -> wait one completes -> list(complete) returns 1, list(all) returns 2

    RPC-10: TestIntegration_SystemGetVersion
    - Call system.getVersion -> verify "1.0.0-test", "abc123", "integration"

    RPC-11: TestIntegration_WebSocketNotifications
    - Connect WS -> add download -> read messages from WS -> verify download.complete notification received

    RPC-12: TestIntegration_ErrorCodes
    - Invalid JSON -> check error.code == -32700
    - Unknown method -> -32601
    - download.status with fake GID -> -32001
    - download.add with missing url -> -32602

    Full lifecycle:
    TestIntegration_FullLifecycle
    - add -> status=active -> pause -> status=waiting -> resume -> wait complete -> status=complete -> remove -> status=-32001

    Concurrent:
    TestIntegration_ConcurrentDownloads
    - 2 goroutines each add a download -> both complete -> list returns 2

    PHASE C: Fix any broken tests from signature changes

    If NewServer/NewWebServer signatures changed across 05-01/05-02/05-03 and existing tests (server_test.go, api_test.go) have outdated calls, update them here. This is a fixup pass.

    PHASE D: Run gate checks

    ```bash
    # Full test suite
    go test ./... -count=1

    # Race detection
    go test -race -short ./...

    # Coverage gate
    scripts/check_coverage.sh

    # Build verification
    go build -ldflags='-w -s' .

    # Vet
    go vet ./...
    ```

    If coverage is below 80% for any package, add targeted tests to bring it up.
    If race detector finds issues, fix them.
    If build fails, fix compilation.

    PHASE E: REFACTOR

    - Clean up helper functions if duplicated across test files
    - Ensure test timeouts are reasonable (2-5 seconds for integration tests)
    - Add t.Parallel() where tests don't share state
    - go fmt, go vet
  </implementation>
</feature>

<verification>
```bash
cd /Users/divkix/GitHub/warpdl/.claude/worktrees/issues-fix

# Integration tests only
go test -v -run "TestIntegration" ./internal/server/ -count=1 -timeout=60s

# All RPC tests (unit + integration)
go test -v -run "TestRPC|TestIntegration|TestRequireToken" ./internal/server/ -count=1

# Full server package
go test -v ./internal/server/ -count=1 -timeout=120s

# Full suite -- MUST pass
go test ./... -count=1

# Race detection -- MUST pass
go test -race -short ./...

# Coverage gate -- MUST pass
scripts/check_coverage.sh

# Build verification -- MUST succeed
go build -ldflags='-w -s' .

# Vet -- MUST be clean
go vet ./...

# CMD tests regression
WARPDL_TEST_SKIP_DAEMON=1 go test ./cmd/ -count=1

# API tests regression
go test ./internal/api/ -count=1
```
</verification>

<success_criteria>
- All 12 RPC requirements (RPC-01 through RPC-12) have at least one integration test
- End-to-end HTTP JSON-RPC call works: send request, get response
- End-to-end WebSocket JSON-RPC works: connect, call method, get response
- Auth enforcement verified for both HTTP and WebSocket
- Full download lifecycle works over RPC: add -> status -> pause -> resume -> complete -> remove
- WebSocket notifications received during download
- Concurrent downloads work via RPC
- Error codes verified: -32700, -32601, -32602, -32001, -32002
- go test ./... passes with zero failures
- go test -race -short ./... passes with zero data races
- scripts/check_coverage.sh passes (all packages >= 80%)
- go build -ldflags='-w -s' . succeeds
- go vet ./... clean
- Existing cmd/ and api/ tests pass unchanged
- No goroutine leaks (bridge and notifier cleaned up in Shutdown)
</success_criteria>

<output>
After completion, create `.planning/phases/05-json-rpc-20/05-04-SUMMARY.md`
</output>
