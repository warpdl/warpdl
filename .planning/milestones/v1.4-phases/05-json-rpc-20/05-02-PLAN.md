---
phase: 05-json-rpc-20
plan: 02
type: tdd
wave: 2
depends_on: [05-01]
files_modified:
  - internal/server/rpc_methods.go
  - internal/server/rpc_methods_test.go
  - internal/server/web.go
  - internal/server/server.go
  - cmd/daemon_core.go
autonomous: true
requirements: [RPC-05, RPC-06, RPC-07, RPC-08, RPC-09]

must_haves:
  truths:
    - "download.add method accepts {url, fileName, dir, headers, connections} params, creates download via Manager, returns {gid} (RPC-05)"
    - "download.add calls warplib.NewDownloader for HTTP/HTTPS URLs and schemeRouter.NewDownloader for FTP/FTPS/SFTP"
    - "download.add starts download in background goroutine (go d.Start() or go pd.Download()) -- does NOT block RPC response"
    - "download.add with missing url param returns jrpc2.Error with code -32602 (Invalid params)"
    - "download.add returns download hash as 'gid' field in result"
    - "download.pause accepts {gid} param, calls item.StopDownload(), returns empty result (RPC-06)"
    - "download.pause with non-existent GID returns jrpc2.Error with code -32001 ('download not found')"
    - "download.pause with GID of non-running download returns jrpc2.Error with code -32002 ('download not running')"
    - "download.resume accepts {gid} param, calls Manager.ResumeDownload, starts resume in background goroutine (RPC-06)"
    - "download.resume with non-existent GID returns jrpc2.Error with code -32001"
    - "download.remove accepts {gid} param, calls Manager.FlushOne(gid), returns empty result (RPC-07)"
    - "download.remove with non-existent GID returns jrpc2.Error with code -32001"
    - "download.status accepts {gid} param, returns {gid, status, totalLength, completedLength, percentage, fileName} (RPC-08)"
    - "download.status 'status' field is 'active' when IsDownloading(), 'complete' when Downloaded>=TotalSize&&TotalSize>0, 'waiting' otherwise"
    - "download.status with non-existent GID returns jrpc2.Error with code -32001"
    - "download.list accepts optional {status} param ('active'/'waiting'/'complete'/'all'), returns array of download summaries (RPC-09)"
    - "download.list with status='active' returns only IsDownloading() items"
    - "download.list with status='complete' returns only completed items"
    - "download.list with no status param defaults to 'all'"
    - "RPCServer struct has manager, client, pool, and schemeRouter fields for method dispatch"
    - "NewRPCServer updated to accept manager, client, pool, schemeRouter as dependencies"
    - "All custom error codes use jrpc2.Code type: -32001 (download not found), -32002 (download not running)"
  artifacts:
    - path: "internal/server/rpc_methods.go"
      provides: "download.add, download.pause, download.resume, download.remove, download.status, download.list method handlers; param/result structs; error code constants"
    - path: "internal/server/rpc_methods_test.go"
      provides: "Tests for all download.* methods: success paths, error paths, edge cases"
  key_links:
    - from: "internal/server/rpc_methods.go:downloadAdd"
      to: "pkg/warplib/dloader.go:NewDownloader"
      via: "Creates HTTP downloader for add"
      pattern: "NewDownloader"
    - from: "internal/server/rpc_methods.go:downloadAdd"
      to: "pkg/warplib/protocol_router.go:SchemeRouter.NewDownloader"
      via: "Creates protocol downloader for FTP/SFTP add"
      pattern: "schemeRouter\\.NewDownloader"
    - from: "internal/server/rpc_methods.go:downloadPause"
      to: "pkg/warplib/item.go:Item.StopDownload"
      via: "Pause = stop in-progress download"
      pattern: "StopDownload"
    - from: "internal/server/rpc_methods.go:downloadResume"
      to: "pkg/warplib/manager.go:Manager.ResumeDownload"
      via: "Resume from persisted state"
      pattern: "ResumeDownload"
    - from: "internal/server/rpc_methods.go:downloadRemove"
      to: "pkg/warplib/manager.go:Manager.FlushOne"
      via: "Remove download from manager"
      pattern: "FlushOne"
    - from: "internal/server/rpc_methods.go:downloadStatus"
      to: "pkg/warplib/item.go:Item"
      via: "Read item state for status response"
      pattern: "GetItem"
    - from: "internal/server/rpc_methods.go:downloadList"
      to: "pkg/warplib/manager.go:Manager.GetItems"
      via: "List downloads filtered by state"
      pattern: "GetItems|GetIncompleteItems|GetCompletedItems"
---

<objective>
Implement the full download.* method suite (add, pause, resume, remove, status, list) as thin adapters over existing Manager and Item APIs.

Purpose: Plan 05-01 delivered the HTTP bridge, auth, and system.getVersion. This plan adds all six download methods that map to existing internal/api handler logic. The methods are thin wrappers -- no new download logic, just JSON-RPC parameter parsing and delegation to Manager/Item/Pool/SchemeRouter. Error handling uses jrpc2.Error with custom codes (-32001 download not found, -32002 not running).

Output: Updated rpc_methods.go with all download.* handlers, comprehensive tests.
</objective>

<execution_context>
@/Users/divkix/.claude/get-shit-done/workflows/execute-plan.md
@/Users/divkix/.claude/get-shit-done/templates/summary.md
@/Users/divkix/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/05-json-rpc-20/05-RESEARCH.md
@.planning/phases/05-json-rpc-20/05-01-PLAN.md

@internal/server/rpc_methods.go (from 05-01)
@internal/server/rpc_auth.go (from 05-01)
@internal/server/web.go
@internal/server/pool.go
@internal/api/download.go
@internal/api/stop.go
@internal/api/resume.go
@internal/api/list.go
@internal/api/flush.go
@pkg/warplib/manager.go
@pkg/warplib/item.go
@pkg/warplib/dloader.go
@pkg/warplib/protocol_router.go
@common/types.go
</context>

<interfaces>
<!-- Key types and contracts the executor needs. -->

From pkg/warplib/manager.go -- Manager methods for RPC:
```go
func (m *Manager) GetItem(hash string) *Item
func (m *Manager) GetItems() []*Item
func (m *Manager) GetIncompleteItems() []*Item
func (m *Manager) GetCompletedItems() []*Item
func (m *Manager) AddDownload(d *Downloader, opts *AddDownloadOpts) error
func (m *Manager) AddProtocolDownload(pd ProtocolDownloader, probe ProbeResult, cleanURL string, proto Protocol, handlers *Handlers, opts *AddDownloadOpts) error
func (m *Manager) ResumeDownload(client *http.Client, hash string, opts *ResumeDownloadOpts) (*Item, error)
func (m *Manager) FlushOne(hash string) error
func (m *Manager) Flush() error
```

From pkg/warplib/item.go -- Item methods for status/pause:
```go
func (i *Item) IsDownloading() bool
func (i *Item) IsStopped() bool
func (i *Item) StopDownload() error
func (i *Item) GetPercentage() int64
func (i *Item) GetSavePath() string
// Fields: Hash, Name, Url, TotalSize, Downloaded, DownloadLocation, DateAdded
// ContentLength is type alias for int64
```

From pkg/warplib/protocol_router.go:
```go
func (r *SchemeRouter) NewDownloader(rawURL string, opts *DownloaderOpts) (ProtocolDownloader, error)
```

From internal/server/pool.go -- Pool for checking active downloads:
```go
func (p *Pool) HasDownload(uid string) bool
func (p *Pool) AddDownload(uid string, sconn *SyncConn)
func (p *Pool) StopDownload(uid string)
```

From github.com/creachadair/jrpc2:
```go
// Custom error
&jrpc2.Error{Code: jrpc2.Code(-32001), Message: "download not found"}

// handler.New for typed params
handler.New(func(ctx context.Context, p AddParams) (*AddResult, error) { ... })
```

Custom error code constants to define in rpc_methods.go:
```go
const (
    codeDownloadNotFound  = jrpc2.Code(-32001)
    codeDownloadNotActive = jrpc2.Code(-32002)
    codeInvalidParams     = jrpc2.Code(-32602)
)
```
</interfaces>

<feature>
  <name>JSON-RPC Download Method Suite</name>
  <files>internal/server/rpc_methods.go, internal/server/rpc_methods_test.go</files>
  <behavior>
    Test cases for RPC-05 (download.add):
    1. download.add with {url: "http://example.com/file.bin"} creates download, returns {gid: "<hash>"}
    2. download.add with missing url returns error code -32602 (Invalid params)
    3. download.add with optional fileName, dir, connections params passes them to DownloaderOpts
    4. download.add with FTP URL dispatches through SchemeRouter
    5. download.add result gid matches the download's hash in Manager

    Test cases for RPC-06 (download.pause + download.resume):
    6. download.pause with valid active GID calls StopDownload, returns empty result
    7. download.pause with non-existent GID returns error code -32001
    8. download.pause with non-active GID (not in pool) returns error code -32002
    9. download.resume with valid GID triggers Manager.ResumeDownload, returns empty result
    10. download.resume with non-existent GID returns error code -32001

    Test cases for RPC-07 (download.remove):
    11. download.remove with valid GID calls FlushOne, returns empty result
    12. download.remove with non-existent GID returns error code -32001 (FlushOne returns error)

    Test cases for RPC-08 (download.status):
    13. download.status with valid GID returns {gid, status, totalLength, completedLength, percentage, fileName}
    14. download.status for active download: status="active"
    15. download.status for completed download (Downloaded>=TotalSize>0): status="complete"
    16. download.status for waiting download: status="waiting"
    17. download.status with non-existent GID returns error code -32001

    Test cases for RPC-09 (download.list):
    18. download.list with no filter returns all items
    19. download.list with status="active" returns only downloading items
    20. download.list with status="complete" returns only completed items
    21. download.list with status="waiting" returns only incomplete non-downloading items
    22. download.list returns array of {gid, status, totalLength, completedLength, fileName}
    23. download.list with empty manager returns empty array (not null)
  </behavior>
  <implementation>
    PHASE A: Define param/result structs in rpc_methods.go

    ```go
    // Error codes for download operations
    const (
        codeDownloadNotFound  = jrpc2.Code(-32001)
        codeDownloadNotActive = jrpc2.Code(-32002)
        codeInvalidParams     = jrpc2.Code(-32602)
    )

    // AddParams is the input for download.add.
    type AddParams struct {
        URL         string          `json:"url"`
        FileName    string          `json:"fileName,omitempty"`
        Dir         string          `json:"dir,omitempty"`
        Headers     warplib.Headers `json:"headers,omitempty"`
        Connections int32           `json:"connections,omitempty"`
        SSHKeyPath  string          `json:"sshKeyPath,omitempty"`
    }

    // AddResult is the response for download.add.
    type AddResult struct {
        GID string `json:"gid"`
    }

    // GIDParam is a common input with just a download GID.
    type GIDParam struct {
        GID string `json:"gid"`
    }

    // StatusResult is the response for download.status.
    type StatusResult struct {
        GID             string `json:"gid"`
        Status          string `json:"status"`
        TotalLength     int64  `json:"totalLength"`
        CompletedLength int64  `json:"completedLength"`
        Percentage      int64  `json:"percentage"`
        FileName        string `json:"fileName"`
    }

    // ListParams is the input for download.list.
    type ListParams struct {
        Status string `json:"status,omitempty"` // "active", "waiting", "complete", "all" (default)
    }

    // ListItem is a single entry in the download.list response.
    type ListItem struct {
        GID             string `json:"gid"`
        Status          string `json:"status"`
        TotalLength     int64  `json:"totalLength"`
        CompletedLength int64  `json:"completedLength"`
        FileName        string `json:"fileName"`
    }

    // ListResult is the response for download.list.
    type ListResult struct {
        Downloads []*ListItem `json:"downloads"`
    }
    ```

    PHASE B: Update RPCServer struct and NewRPCServer

    Add fields to RPCServer:
    ```go
    type RPCServer struct {
        bridge       *jhttp.Bridge
        secret       string
        version      string
        commit       string
        buildType    string
        manager      *warplib.Manager
        client       *http.Client
        pool         *Pool
        schemeRouter *warplib.SchemeRouter
    }
    ```

    Update NewRPCServer to accept dependencies:
    ```go
    func NewRPCServer(cfg *RPCConfig, m *warplib.Manager, client *http.Client, pool *Pool, router *warplib.SchemeRouter) *RPCServer {
        rs := &RPCServer{
            secret:       cfg.Secret,
            version:      cfg.Version,
            commit:       cfg.Commit,
            buildType:    cfg.BuildType,
            manager:      m,
            client:       client,
            pool:         pool,
            schemeRouter: router,
        }
        methods := handler.Map{
            "system.getVersion": handler.New(rs.systemGetVersion),
            "download.add":     handler.New(rs.downloadAdd),
            "download.pause":   handler.New(rs.downloadPause),
            "download.resume":  handler.New(rs.downloadResume),
            "download.remove":  handler.New(rs.downloadRemove),
            "download.status":  handler.New(rs.downloadStatus),
            "download.list":    handler.New(rs.downloadList),
        }
        rs.bridge = jhttp.NewBridge(methods, nil)
        return rs
    }
    ```

    IMPORTANT: Also update NewWebServer to pass manager, client, pool, schemeRouter to NewRPCServer. The RPCConfig struct may need to carry these or they can be passed separately.

    Update web.go NewWebServer:
    ```go
    func NewWebServer(l *log.Logger, m *warplib.Manager, pool *Pool, port int, rpcCfg *RPCConfig, client *http.Client, router *warplib.SchemeRouter) *WebServer {
        ws := &WebServer{port: port, l: l, m: m, pool: pool}
        if rpcCfg != nil && rpcCfg.Secret != "" {
            ws.rpc = NewRPCServer(rpcCfg, m, client, pool, router)
            ws.listenAll = rpcCfg.ListenAll
        }
        return ws
    }
    ```

    And update server.go NewServer to pass client and router:
    ```go
    func NewServer(l *log.Logger, m *warplib.Manager, port int, rpcCfg *RPCConfig, client *http.Client, router *warplib.SchemeRouter) *Server {
        pool := NewPool(l)
        return &Server{
            // ...
            ws: NewWebServer(l, m, pool, port+1, rpcCfg, client, router),
        }
    }
    ```

    And update daemon_core.go NewServer call to pass client and router.

    PHASE C: RED -- Write failing tests in rpc_methods_test.go

    Tests use a test helper that creates a Manager with temp dir, a mock HTTP server, and constructs an RPCServer for direct handler testing via the bridge.

    ```go
    // testRPCSetup creates a test RPCServer with real Manager + mock HTTP server
    func testRPCSetup(t *testing.T) (*RPCServer, *httptest.Server, func()) {
        t.Helper()
        base := t.TempDir()
        warplib.SetConfigDir(base)
        m, _ := warplib.InitManager()
        content := bytes.Repeat([]byte("x"), 1024)
        srv := newRangeServer(content) // reuse from web_test.go
        pool := NewPool(log.New(io.Discard, "", 0))
        client := &http.Client{}
        rpcCfg := &RPCConfig{
            Secret:  "test-secret",
            Version: "1.0.0",
            Commit:  "abc123",
        }
        rs := NewRPCServer(rpcCfg, m, client, pool, nil)
        return rs, srv, func() { srv.Close(); m.Close(); rs.Close() }
    }

    // rpcCall sends a JSON-RPC request through the bridge and returns the response
    func rpcCall(t *testing.T, bridge *jhttp.Bridge, method string, params any) map[string]any {
        t.Helper()
        // Marshal JSON-RPC request, send to bridge via httptest.ResponseRecorder
        // Return parsed response
    }
    ```

    PHASE D: GREEN -- Implement method handlers

    download.add:
    - Validate URL is present
    - Parse URL scheme; for ftp/ftps/sftp use SchemeRouter, for http/https use NewDownloader
    - For HTTP: create Downloader with minimal handlers (RPC handlers just update pool, no sconn needed)
    - AddDownload to manager
    - pool.AddDownload with nil sconn (RPC clients don't use CLI binary protocol)
    - go d.Start() (background)
    - Return {gid: hash}

    download.pause:
    - Get item from manager, check exists (error -32001)
    - Check pool.HasDownload (error -32002 if not active)
    - Call item.StopDownload()
    - Return empty struct

    download.resume:
    - Get item from manager, check exists (error -32001)
    - Call manager.ResumeDownload with minimal handlers
    - pool.AddDownload
    - go item.Resume() (background)
    - Return empty struct

    download.remove:
    - Call manager.FlushOne(gid)
    - If error (not found), return -32001
    - Return empty struct

    download.status:
    - Get item from manager (error -32001 if nil)
    - Determine status string from IsDownloading() and Downloaded/TotalSize
    - Return StatusResult

    download.list:
    - Based on status param: GetItems (all), filter by IsDownloading (active), GetCompletedItems (complete), GetIncompleteItems minus active (waiting)
    - Map items to ListItem structs
    - Return ListResult with Downloads array (never nil, use empty slice)

    Helper:
    ```go
    func itemStatus(item *warplib.Item) string {
        if item.IsDownloading() {
            return "active"
        }
        if item.Downloaded >= item.TotalSize && item.TotalSize > 0 {
            return "complete"
        }
        return "waiting"
    }
    ```

    PHASE E: REFACTOR + Full caller fixup sweep

    This phase handles ALL caller fixups for NewWebServer, NewServer, and NewRPCServer
    signature changes from BOTH Plan 05-01 and this plan (05-02). Plan 05-01 deferred its
    test-file caller fixups here since we re-widen the signatures in Phase B anyway.

    Search for all call sites and update:
    - internal/server/web_test.go: NewWebServer calls -- add nil/correct params for rpcCfg, client, router
    - internal/server/server_test.go: NewServer calls -- add nil/correct params for rpcCfg, client, router
    - internal/server/rpc_methods_test.go: NewRPCServer calls -- update to new signature with manager, client, pool, router
    - internal/server/rpc_auth_test.go: Any test helpers referencing RPCServer -- update if needed
    - internal/api/api_test.go: If any tests construct Server -- update NewServer calls
    - cmd/daemon_core.go: NewServer call -- pass client and router (already partially done in 05-01 Phase H)

    After fixup:
    - Verify all existing tests still pass (zero regression)
    - go fmt, go vet
    - Verify coverage >= 80%
  </implementation>
</feature>

<verification>
```bash
cd /Users/divkix/GitHub/warpdl/.claude/worktrees/issues-fix

# download.add tests
go test -v -run "TestRPCDownloadAdd" ./internal/server/ -count=1

# download.pause + resume tests
go test -v -run "TestRPCDownload(Pause|Resume)" ./internal/server/ -count=1

# download.remove tests
go test -v -run "TestRPCDownloadRemove" ./internal/server/ -count=1

# download.status tests
go test -v -run "TestRPCDownloadStatus" ./internal/server/ -count=1

# download.list tests
go test -v -run "TestRPCDownloadList" ./internal/server/ -count=1

# All RPC tests
go test -v -run "TestRPC" ./internal/server/ -count=1

# Full server package
go test -v ./internal/server/ -count=1

# Full suite -- zero regression
go test ./... -count=1

# Race detection
go test -race -short ./internal/server/...

# Coverage
go test -cover ./internal/server/...

# Vet
go vet ./...
```
</verification>

<success_criteria>
- RED: Failing tests for all six download.* methods
- GREEN: All tests pass after implementation
- REFACTOR: Clean code, consistent error handling
- download.add creates download and returns GID
- download.add with missing URL returns -32602
- download.add supports HTTP and protocol (FTP/SFTP) URLs via SchemeRouter
- download.pause stops active download
- download.pause returns -32001 for unknown GID, -32002 for non-active
- download.resume triggers Manager.ResumeDownload in background
- download.remove calls FlushOne
- download.status returns correct status string (active/complete/waiting)
- download.status returns totalLength, completedLength, percentage, fileName
- download.list filters by status param
- download.list returns empty array (not null) when no items
- Custom error codes: -32001 (not found), -32002 (not active), -32602 (invalid params)
- All 05-01 tests still pass (NewRPCServer signature may have changed)
- All existing tests pass -- zero regression
- go vet ./... clean
- Coverage >= 80% on internal/server
</success_criteria>

<output>
After completion, create `.planning/phases/05-json-rpc-20/05-02-SUMMARY.md`
</output>
