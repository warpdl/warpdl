---
phase: 05-json-rpc-20
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - internal/server/web.go
  - internal/server/web_test.go
  - internal/server/server.go
  - internal/server/rpc_auth.go
  - internal/server/rpc_auth_test.go
  - internal/server/rpc_methods.go
  - internal/server/rpc_methods_test.go
  - cmd/cmd.go
  - cmd/daemon_core.go
  - go.mod
  - go.sum
autonomous: true
requirements: [RPC-01, RPC-03, RPC-04, RPC-10, RPC-12]

must_haves:
  truths:
    - "go.mod contains github.com/creachadair/jrpc2 v1.3.4 as a direct dependency"
    - "WebServer struct has rpcSecret string field and listenAll bool field"
    - "NewWebServer signature updated to accept RPCConfig struct (or fields: rpcSecret, listenAll)"
    - "WebServer.addr() returns '127.0.0.1:<port>' when listenAll is false (default) (RPC-04)"
    - "WebServer.addr() returns ':<port>' when listenAll is true (RPC-04)"
    - "TestWebServerAddr updated to assert '127.0.0.1:9999' instead of ':9999'"
    - "WebServer.handler() returns http.ServeMux with existing '/' websocket route AND '/jsonrpc' route when rpcSecret is set"
    - "POST /jsonrpc with valid Bearer token returns valid JSON-RPC 2.0 response (RPC-01)"
    - "POST /jsonrpc without auth token returns HTTP 401 with JSON-RPC 2.0 error {code: -32600, message: 'Unauthorized'} (RPC-03)"
    - "POST /jsonrpc with wrong auth token returns HTTP 401 (RPC-03)"
    - "requireToken middleware uses crypto/subtle.ConstantTimeCompare for token comparison (no timing oracle)"
    - "requireToken with empty secret (rpcSecret='') rejects all requests -- RPC requires a secret to be set"
    - "jhttp.Bridge is created from handler.Map and mounted at /jsonrpc with auth middleware wrapping it"
    - "system.getVersion method returns {version, commit, buildType} via jrpc2 handler (RPC-10)"
    - "Malformed JSON POST to /jsonrpc returns JSON-RPC 2.0 error with code -32700 (Parse error) (RPC-12)"
    - "Unknown method POST to /jsonrpc returns JSON-RPC 2.0 error with code -32601 (Method not found) (RPC-12)"
    - "WebServer.Shutdown() calls bridge.Close() to clean up jrpc2 internal server goroutines"
    - "cmd/cmd.go daemon command has --rpc-secret flag (env: WARPDL_RPC_SECRET) and --rpc-listen-all flag"
    - "initDaemonComponents passes RPCConfig (secret, listenAll) to NewServer which passes to NewWebServer"
    - "When --rpc-secret is not set, RPC endpoint is NOT mounted (no /jsonrpc route) -- RPC is opt-in"
    - "Existing browser extension WebSocket at '/' continues to work (zero regression)"
  artifacts:
    - path: "internal/server/rpc_auth.go"
      provides: "requireToken HTTP middleware, validToken helper using subtle.ConstantTimeCompare"
      exports: []
    - path: "internal/server/rpc_auth_test.go"
      provides: "Tests for auth middleware: valid token, invalid token, missing token, empty secret, constant-time comparison"
    - path: "internal/server/rpc_methods.go"
      provides: "RPCServer struct, NewRPCServer, handler.Map with system.getVersion, bridge lifecycle"
      exports: ["RPCServer", "NewRPCServer", "RPCConfig"]
    - path: "internal/server/rpc_methods_test.go"
      provides: "Tests for system.getVersion, error codes (-32700, -32601), bridge lifecycle"
    - path: "internal/server/web.go"
      provides: "Updated WebServer with RPCConfig, updated handler() with mux routing, updated addr() for localhost binding, updated Shutdown() with bridge cleanup"
    - path: "internal/server/web_test.go"
      provides: "Updated TestWebServerAddr to expect 127.0.0.1:9999"
    - path: "cmd/cmd.go"
      provides: "--rpc-secret and --rpc-listen-all flags on daemon command"
    - path: "cmd/daemon_core.go"
      provides: "RPCConfig threading from CLI flags to NewServer/NewWebServer"
    - path: "go.mod"
      provides: "jrpc2 v1.3.4 dependency"
  key_links:
    - from: "internal/server/rpc_methods.go:RPCServer"
      to: "github.com/creachadair/jrpc2/jhttp:Bridge"
      via: "Bridge wraps handler.Map into http.Handler for /jsonrpc"
      pattern: "jhttp\\.NewBridge"
    - from: "internal/server/rpc_auth.go:requireToken"
      to: "crypto/subtle:ConstantTimeCompare"
      via: "Timing-safe token comparison"
      pattern: "subtle\\.ConstantTimeCompare"
    - from: "internal/server/web.go:handler()"
      to: "internal/server/rpc_methods.go:RPCServer"
      via: "Mount bridge at /jsonrpc when RPC enabled"
      pattern: "/jsonrpc"
    - from: "cmd/daemon_core.go:initDaemonComponents"
      to: "internal/server/rpc_methods.go:RPCConfig"
      via: "CLI flags threaded to server construction"
      pattern: "RPCConfig"
---

<objective>
Add jrpc2 dependency, HTTP JSON-RPC endpoint at /jsonrpc with Bearer token auth middleware, localhost binding, system.getVersion method, standard error codes, and CLI flags for --rpc-secret / --rpc-listen-all.

Purpose: This is the foundational JSON-RPC plan. It adds the jrpc2 library, creates the HTTP bridge endpoint, wires auth middleware with constant-time comparison, fixes WebServer.addr() for localhost-only default binding, adds the first method (system.getVersion), ensures standard JSON-RPC 2.0 error codes work automatically, and threads the RPC config from CLI flags through the daemon initialization chain. Plan 05-02 adds the remaining methods, Plan 05-03 adds WebSocket.

Output: rpc_auth.go (middleware), rpc_methods.go (RPCServer + system.getVersion), updated web.go (mux, addr, shutdown), updated cmd/cmd.go and daemon_core.go (flags + threading), updated go.mod.
</objective>

<execution_context>
@/Users/divkix/.claude/get-shit-done/workflows/execute-plan.md
@/Users/divkix/.claude/get-shit-done/templates/summary.md
@/Users/divkix/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/05-json-rpc-20/05-RESEARCH.md

@internal/server/web.go
@internal/server/web_test.go
@internal/server/server.go
@internal/server/pool.go
@internal/api/api.go
@internal/api/version.go
@cmd/cmd.go
@cmd/daemon_core.go
@go.mod
</context>

<interfaces>
<!-- Key types and contracts the executor needs. -->

From github.com/creachadair/jrpc2 v1.3.4:
```go
// jhttp.Bridge is an http.Handler that bridges HTTP POST to jrpc2 server
import "github.com/creachadair/jrpc2/jhttp"
bridge := jhttp.NewBridge(methods, nil) // methods is handler.ServiceMap or handler.Map
bridge.Close() // MUST call on shutdown

// handler.Map maps method names to handlers
import "github.com/creachadair/jrpc2/handler"
methods := handler.Map{
    "system.getVersion": handler.New(fn),
}

// handler.New wraps a function into jrpc2.Handler
// Signatures: func(ctx) (result, error) or func(ctx, params) (result, error)
handler.New(func(ctx context.Context) (*VersionResult, error) { ... })

// jrpc2.Error for custom error codes
type Error struct {
    Code    Code
    Message string
}
// Predefined codes: -32700 ParseError, -32600 InvalidRequest, -32601 MethodNotFound
// Custom server codes: -32000 to -32099
```

From internal/server/web.go -- current WebServer:
```go
type WebServer struct {
    port   int
    l      *log.Logger
    m      *warplib.Manager
    pool   *Pool
    server *http.Server
    mu     sync.Mutex
}

func NewWebServer(l *log.Logger, m *warplib.Manager, pool *Pool, port int) *WebServer
func (s *WebServer) handler() http.Handler  // currently returns single websocket.Handler
func (s *WebServer) addr() string           // currently returns ":<port>" -- MUST change to "127.0.0.1:<port>"
func (s *WebServer) Start() error
func (s *WebServer) Shutdown(ctx context.Context) error
```

From internal/server/server.go -- Server creates WebServer:
```go
func NewServer(l *log.Logger, m *warplib.Manager, port int) *Server {
    pool := NewPool(l)
    return &Server{
        // ...
        ws: NewWebServer(l, m, pool, port+1),
    }
}
```

From cmd/daemon_core.go -- initDaemonComponents creates Server:
```go
serv := server.NewServer(stdLog, m, DEF_PORT)
```

From internal/api/api.go -- Api has version fields:
```go
type Api struct {
    version   string
    commit    string
    buildType string
    // ...
}
```
</interfaces>

<feature>
  <name>JSON-RPC 2.0 HTTP Endpoint with Auth and Localhost Binding</name>
  <files>internal/server/rpc_auth.go, internal/server/rpc_auth_test.go, internal/server/rpc_methods.go, internal/server/rpc_methods_test.go, internal/server/web.go, internal/server/web_test.go, cmd/cmd.go, cmd/daemon_core.go, go.mod, go.sum</files>
  <behavior>
    Test cases for RPC-01 (HTTP endpoint at /jsonrpc):
    1. POST /jsonrpc with valid auth token and {"jsonrpc":"2.0","method":"system.getVersion","id":1} returns HTTP 200 with JSON-RPC 2.0 response containing "result" key
    2. POST /jsonrpc response has "jsonrpc":"2.0" and matching "id" in response
    3. WebServer.handler() returns mux with /jsonrpc route when RPC is configured

    Test cases for RPC-03 (auth token required):
    4. POST /jsonrpc without Authorization header returns HTTP 401 with JSON-RPC error {code:-32600, message:"Unauthorized"}
    5. POST /jsonrpc with wrong Bearer token returns HTTP 401
    6. POST /jsonrpc with correct Bearer token returns HTTP 200 with valid response
    7. requireToken uses subtle.ConstantTimeCompare (verified by test that checks both equal and unequal tokens pass/fail correctly -- no timing-based shortcut)
    8. When rpcSecret is empty string, RPC endpoint is NOT mounted (handler() returns mux without /jsonrpc)

    Test cases for RPC-04 (localhost binding):
    9. WebServer with listenAll=false: addr() returns "127.0.0.1:9999"
    10. WebServer with listenAll=true: addr() returns ":9999"
    11. UPDATE existing TestWebServerAddr to expect "127.0.0.1:9999" (was ":9999")

    Test cases for RPC-10 (system.getVersion):
    12. system.getVersion returns {"version":"1.0.0","commit":"abc123","buildType":"release"} matching RPCServer fields
    13. system.getVersion with no params (none required) succeeds

    Test cases for RPC-12 (standard error codes):
    14. POST /jsonrpc with invalid JSON body returns JSON-RPC error code -32700 (Parse error)
    15. POST /jsonrpc with {"jsonrpc":"2.0","method":"nonexistent.method","id":1} returns error code -32601 (Method not found)
    16. POST /jsonrpc with valid JSON but missing "method" field returns error code -32600 (Invalid request)

    Lifecycle/regression:
    17. WebServer.Shutdown() calls bridge.Close() -- no goroutine leaks
    18. Existing browser extension WebSocket at "/" still works after mux conversion
    19. NewWebServer with empty rpcSecret: handler() only has "/" route, no "/jsonrpc"

    CLI flags:
    20. daemon command has --rpc-secret flag with EnvVar WARPDL_RPC_SECRET
    21. daemon command has --rpc-listen-all flag (bool, default false)
  </behavior>
  <implementation>
    PHASE A: Add jrpc2 dependency

    1. Run: cd /Users/divkix/GitHub/warpdl/.claude/worktrees/issues-fix && go get github.com/creachadair/jrpc2@v1.3.4
    2. Run: go mod tidy
    3. Verify jrpc2 appears in go.mod as direct dependency

    PHASE B: RED -- Write failing tests

    Batch 1: Auth middleware tests (rpc_auth_test.go)
    ```go
    package server

    import (
        "encoding/json"
        "net/http"
        "net/http/httptest"
        "strings"
        "testing"
    )

    func TestRequireToken_ValidToken(t *testing.T) {
        // Create handler behind auth middleware, send request with correct Bearer token
        // Expect 200 OK
    }

    func TestRequireToken_MissingToken(t *testing.T) {
        // Send request without Authorization header
        // Expect 401 with JSON-RPC error {code:-32600, message:"Unauthorized"}
    }

    func TestRequireToken_WrongToken(t *testing.T) {
        // Send request with wrong Bearer token
        // Expect 401
    }

    func TestRequireToken_EmptySecret(t *testing.T) {
        // requireToken with empty secret should reject all requests
        // This ensures RPC cannot accidentally run without auth
    }

    func TestRequireToken_BearerPrefix(t *testing.T) {
        // Token sent as "Bearer <token>" in Authorization header
        // Verify prefix stripping works correctly
    }
    ```

    Batch 2: RPCServer + system.getVersion tests (rpc_methods_test.go)
    ```go
    package server

    import (
        "bytes"
        "encoding/json"
        "net/http"
        "net/http/httptest"
        "testing"
    )

    func TestRPCSystemGetVersion(t *testing.T) {
        // Create RPCServer with version/commit/buildType
        // POST system.getVersion via HTTP bridge
        // Assert response matches
    }

    func TestRPCParseError(t *testing.T) {
        // POST invalid JSON to bridge
        // Assert error code -32700
    }

    func TestRPCMethodNotFound(t *testing.T) {
        // POST valid JSON-RPC with unknown method
        // Assert error code -32601
    }

    func TestRPCBridgeLifecycle(t *testing.T) {
        // Create bridge, close it, verify no panics
    }
    ```

    Batch 3: WebServer integration tests (update web_test.go)
    ```go
    // UPDATE TestWebServerAddr:
    func TestWebServerAddr(t *testing.T) {
        // Default (listenAll=false): expect "127.0.0.1:9999"
    }

    func TestWebServerAddr_ListenAll(t *testing.T) {
        // listenAll=true: expect ":9999"
    }

    func TestWebServerHandler_WithRPC(t *testing.T) {
        // Create WebServer with rpcSecret set
        // Verify /jsonrpc route exists and responds
    }

    func TestWebServerHandler_WithoutRPC(t *testing.T) {
        // Create WebServer without rpcSecret
        // Verify /jsonrpc route does NOT exist (404)
    }

    func TestWebServerExistingWebSocket(t *testing.T) {
        // Verify existing "/" websocket route still works after mux conversion
    }
    ```

    PHASE C: GREEN -- Implement rpc_auth.go

    Create internal/server/rpc_auth.go:
    ```go
    package server

    import (
        "crypto/subtle"
        "encoding/json"
        "net/http"
        "strings"
    )

    // requireToken wraps an http.Handler with Bearer token authentication.
    // Returns JSON-RPC 2.0 error response on auth failure (not plain HTTP error).
    // Uses subtle.ConstantTimeCompare to prevent timing attacks on the secret.
    //
    // If secret is empty, all requests are rejected -- RPC requires explicit opt-in.
    func requireToken(secret string, next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            token := strings.TrimPrefix(r.Header.Get("Authorization"), "Bearer ")

            if secret == "" || subtle.ConstantTimeCompare([]byte(token), []byte(secret)) != 1 {
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusUnauthorized)
                json.NewEncoder(w).Encode(map[string]any{
                    "jsonrpc": "2.0",
                    "error": map[string]any{
                        "code":    -32600,
                        "message": "Unauthorized",
                    },
                    "id": nil,
                })
                return
            }
            next.ServeHTTP(w, r)
        })
    }
    ```

    PHASE D: GREEN -- Implement rpc_methods.go

    Create internal/server/rpc_methods.go:
    ```go
    package server

    import (
        "context"

        "github.com/creachadair/jrpc2/handler"
        "github.com/creachadair/jrpc2/jhttp"
    )

    // RPCConfig holds configuration for the JSON-RPC endpoint.
    type RPCConfig struct {
        Secret    string // Auth token (required -- empty means RPC disabled)
        ListenAll bool   // If true, bind to 0.0.0.0 instead of 127.0.0.1
        Version   string // Daemon version
        Commit    string // Git commit
        BuildType string // Build type
    }

    // RPCServer manages the JSON-RPC 2.0 bridge and method handlers.
    type RPCServer struct {
        bridge    *jhttp.Bridge
        secret    string
        version   string
        commit    string
        buildType string
    }

    // VersionResult is the response for system.getVersion.
    type VersionResult struct {
        Version   string `json:"version"`
        Commit    string `json:"commit,omitempty"`
        BuildType string `json:"buildType,omitempty"`
    }

    // NewRPCServer creates a new RPCServer with method handlers and HTTP bridge.
    func NewRPCServer(cfg *RPCConfig) *RPCServer {
        rs := &RPCServer{
            secret:    cfg.Secret,
            version:   cfg.Version,
            commit:    cfg.Commit,
            buildType: cfg.BuildType,
        }

        methods := handler.Map{
            "system.getVersion": handler.New(rs.systemGetVersion),
            // download.* methods added in Plan 05-02
        }

        rs.bridge = jhttp.NewBridge(methods, nil)
        return rs
    }

    func (rs *RPCServer) systemGetVersion(ctx context.Context) (*VersionResult, error) {
        return &VersionResult{
            Version:   rs.version,
            Commit:    rs.commit,
            BuildType: rs.buildType,
        }, nil
    }

    // Close shuts down the jrpc2 bridge, releasing internal goroutines.
    func (rs *RPCServer) Close() {
        if rs.bridge != nil {
            rs.bridge.Close()
        }
    }
    ```

    PHASE E: GREEN -- Update web.go

    Modify WebServer struct:
    - Add `rpcSecret string` field
    - Add `listenAll bool` field
    - Add `rpc *RPCServer` field

    Update NewWebServer signature:
    ```go
    func NewWebServer(l *log.Logger, m *warplib.Manager, pool *Pool, port int, rpcCfg *RPCConfig) *WebServer {
        ws := &WebServer{port: port, l: l, m: m, pool: pool, listenAll: false}
        if rpcCfg != nil && rpcCfg.Secret != "" {
            ws.rpc = NewRPCServer(rpcCfg)
            ws.listenAll = rpcCfg.ListenAll
        }
        return ws
    }
    ```

    Update handler():
    ```go
    func (s *WebServer) handler() http.Handler {
        mux := http.NewServeMux()
        mux.Handle("/", websocket.Handler(s.handleConnection))
        if s.rpc != nil {
            mux.Handle("/jsonrpc", requireToken(s.rpc.secret, s.rpc.bridge))
        }
        return mux
    }
    ```

    Update addr():
    ```go
    func (s *WebServer) addr() string {
        if s.listenAll {
            return fmt.Sprintf(":%d", s.port)
        }
        return fmt.Sprintf("127.0.0.1:%d", s.port)
    }
    ```

    Update Shutdown():
    ```go
    func (s *WebServer) Shutdown(ctx context.Context) error {
        s.mu.Lock()
        defer s.mu.Unlock()
        if s.rpc != nil {
            s.rpc.Close()
        }
        if s.server == nil {
            return nil
        }
        return s.server.Shutdown(ctx)
    }
    ```

    PHASE F: Update server.go NewServer

    Update NewServer to accept RPCConfig and pass to NewWebServer:
    ```go
    func NewServer(l *log.Logger, m *warplib.Manager, port int, rpcCfg *RPCConfig) *Server {
        pool := NewPool(l)
        return &Server{
            log:     l,
            pool:    pool,
            handler: make(map[common.UpdateType]HandlerFunc),
            port:    port,
            ws:      NewWebServer(l, m, pool, port+1, rpcCfg),
        }
    }
    ```

    PHASE G: Update cmd/cmd.go -- Add daemon flags

    In daemon command Flags slice, add:
    ```go
    cli.StringFlag{
        Name:   "rpc-secret",
        Usage:  "secret token for JSON-RPC API authentication (required to enable RPC)",
        EnvVar: "WARPDL_RPC_SECRET",
    },
    cli.BoolFlag{
        Name:  "rpc-listen-all",
        Usage: "bind RPC to all interfaces instead of localhost only",
    },
    ```

    PHASE H: Update cmd/daemon_core.go -- Thread RPCConfig

    Update initDaemonComponents signature to accept rpcCfg:
    ```go
    var initDaemonComponents = func(log logger.Logger, maxConcurrent int, rpcCfg *server.RPCConfig) (*DaemonComponents, error) {
        // ... existing init ...
        serv := server.NewServer(stdLog, m, DEF_PORT, rpcCfg)
        // ...
    }
    ```

    Update getDaemonAction() to read flags and construct RPCConfig:
    ```go
    rpcCfg := &server.RPCConfig{
        Secret:    c.String("rpc-secret"),
        ListenAll: c.Bool("rpc-listen-all"),
        Version:   currentBuildArgs.Version,
        Commit:    currentBuildArgs.Commit,
        BuildType: currentBuildArgs.BuildType,
    }
    // Only pass rpcCfg if secret is set
    if rpcCfg.Secret == "" {
        rpcCfg = nil
    }
    ```

    PHASE I: (DEFERRED TO 05-02) Fix all callers of NewWebServer and NewServer

    NOTE: Caller fixup for NewWebServer/NewServer signature changes is deferred to Plan 05-02,
    which changes these same signatures again (adding manager, client, pool, schemeRouter params).
    Doing the fixup here would create throwaway work since 05-02 immediately re-widens the signatures.

    For this plan, only update the DIRECT callers touched by Phases F and H:
    - internal/server/server.go: NewServer updated in Phase F (passes rpcCfg to NewWebServer)
    - cmd/daemon_core.go: NewServer call updated in Phase H (passes rpcCfg)

    All OTHER callers (test files calling NewWebServer/NewServer directly) are fixed in 05-02's
    Phase E alongside the second signature change.

    PHASE J: REFACTOR -- Clean up

    After GREEN:
    - go fmt ./...
    - go vet ./...
    - Verify all existing tests pass (zero regression)
    - Verify coverage >= 80% on internal/server
  </implementation>
</feature>

<verification>
```bash
# Install jrpc2 dependency
cd /Users/divkix/GitHub/warpdl/.claude/worktrees/issues-fix && go get github.com/creachadair/jrpc2@v1.3.4 && go mod tidy

# Auth middleware tests
go test -v -run "TestRequireToken" ./internal/server/ -count=1

# RPC methods tests (system.getVersion, error codes)
go test -v -run "TestRPC" ./internal/server/ -count=1

# WebServer tests (addr, handler, regression)
go test -v -run "TestWebServer" ./internal/server/ -count=1

# All server package tests
go test -v ./internal/server/ -count=1

# Full suite -- zero regression
go test ./... -count=1

# Race detection
go test -race -short ./internal/server/... ./internal/api/... ./cmd/...

# Coverage
go test -cover ./internal/server/...

# Vet
go vet ./...
```
</verification>

<success_criteria>
- RED: Failing tests exist for auth middleware, system.getVersion, error codes, addr() localhost binding
- GREEN: All tests pass after implementation
- REFACTOR: Clean code, no unnecessary exports
- jrpc2 v1.3.4 in go.mod as direct dependency
- POST /jsonrpc with valid token returns JSON-RPC 2.0 response
- POST /jsonrpc without/wrong token returns 401 with JSON-RPC error
- Auth uses subtle.ConstantTimeCompare (no timing oracle)
- Empty rpcSecret means RPC endpoint not mounted
- addr() returns 127.0.0.1:<port> by default (localhost binding)
- addr() returns :<port> when listenAll=true
- system.getVersion returns correct version info
- Parse error returns -32700, method not found returns -32601
- bridge.Close() called in Shutdown() (no goroutine leaks)
- Existing "/" websocket route still works
- --rpc-secret and --rpc-listen-all flags on daemon command
- initDaemonComponents threads RPCConfig to NewServer
- All existing tests pass -- zero regression
- go vet ./... clean
- Coverage >= 80% on internal/server
</success_criteria>

<output>
After completion, create `.planning/phases/05-json-rpc-20/05-01-SUMMARY.md`
</output>
