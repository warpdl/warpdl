---
phase: 06-fix-integration-defects
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - pkg/warplib/item.go
  - pkg/warplib/manager.go
  - pkg/warplib/sftp_resume_key_test.go
  - internal/server/web.go
  - internal/server/web_redirect_test.go
  - internal/api/download.go
  - internal/server/rpc_methods.go
autonomous: true
requirements: [SFTP-04, SFTP-06, REDIR-04]

must_haves:
  truths:
    - "Item struct has SSHKeyPath string field with json tag `json:\"ssh_key_path,omitempty\"`"
    - "AddProtocolDownload persists SSHKeyPath from DownloaderOpts into Item via AddDownloadOpts.SSHKeyPath"
    - "ResumeDownload passes item.SSHKeyPath to SchemeRouter.NewDownloader via DownloaderOpts.SSHKeyPath for FTP/FTPS/SFTP protocols"
    - "GOB round-trip test: encode Item with SSHKeyPath='/custom/key', decode, verify SSHKeyPath survives"
    - "GOB backward compat: decode existing pre_phase2_userdata.warp fixture, verify SSHKeyPath is empty string (zero value)"
    - "Resume test: create SFTP item with SSHKeyPath, simulate resume, verify NewDownloader receives the SSHKeyPath"
    - "Resume test: create SFTP item with empty SSHKeyPath, simulate resume, verify NewDownloader receives empty SSHKeyPath"
    - "web.go processDownload creates http.Client with CheckRedirect: warplib.RedirectPolicy(warplib.DefaultMaxRedirects)"
    - "Test: processDownload http.Client has non-nil CheckRedirect function"
    - "go test -short ./pkg/warplib/... ./internal/server/... passes"
    - "go test -race -short ./pkg/warplib/... ./internal/server/... passes"
  artifacts:
    - path: "pkg/warplib/item.go"
      provides: "Item.SSHKeyPath field for SFTP key persistence across resume cycles"
    - path: "pkg/warplib/manager.go"
      provides: "SSHKeyPath threading in AddProtocolDownload and ResumeDownload"
    - path: "pkg/warplib/sftp_resume_key_test.go"
      provides: "TDD tests for SFTP key persistence and GOB round-trip"
    - path: "internal/server/web.go"
      provides: "Explicit CheckRedirect on processDownload http.Client"
    - path: "internal/server/web_redirect_test.go"
      provides: "TDD test for web.go redirect policy enforcement"
  key_links:
    - from: "pkg/warplib/manager.go:AddProtocolDownload"
      to: "pkg/warplib/item.go:Item.SSHKeyPath"
      via: "Sets item.SSHKeyPath from opts.SSHKeyPath"
      pattern: "item\\.SSHKeyPath"
    - from: "pkg/warplib/manager.go:ResumeDownload"
      to: "pkg/warplib/protocol.go:SchemeRouter.NewDownloader"
      via: "Passes item.SSHKeyPath in DownloaderOpts.SSHKeyPath"
      pattern: "SSHKeyPath.*item\\.SSHKeyPath"
    - from: "internal/server/web.go:processDownload"
      to: "pkg/warplib/redirect.go:RedirectPolicy"
      via: "Sets CheckRedirect on http.Client at construction time"
      pattern: "CheckRedirect.*RedirectPolicy"
---

<objective>
Fix two independent integration defects: (1) SFTP resume loses custom SSH key path because Item struct doesn't persist SSHKeyPath, and (2) web.go processDownload creates http.Client without CheckRedirect, violating the redirect policy established in Phase 1.

Purpose: After this plan, SFTP downloads started with `--ssh-key /custom/key` can be paused and resumed using the same key, and web.go processDownload enforces the same redirect policy as every other http.Client in the codebase.

Output: Item.SSHKeyPath field, threading through AddProtocolDownload/ResumeDownload, GOB round-trip test, web.go 1-line fix with test.
</objective>

<execution_context>
@/Users/divkix/.claude/get-shit-done/workflows/execute-plan.md
@/Users/divkix/.claude/get-shit-done/templates/summary.md
@/Users/divkix/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/06-fix-integration-defects/06-RESEARCH.md

@pkg/warplib/item.go
@pkg/warplib/manager.go (lines 268-305: AddProtocolDownload, lines 548-649: ResumeDownload)
@pkg/warplib/dloader.go (lines 117-183: DownloaderOpts struct with SSHKeyPath)
@pkg/warplib/redirect.go (RedirectPolicy function)
@pkg/warplib/protocol.go (ProtocolDownloader interface, SchemeRouter)
@pkg/warplib/manager_resume_test.go (existing resume test patterns)
@pkg/warplib/protocol_ftp_test.go (AddProtocolDownload test patterns)
@pkg/warplib/testdata/pre_phase2_userdata.warp (GOB backward compat fixture)
@internal/server/web.go (line 56: http.Client without CheckRedirect)
@cmd/daemon_core.go (line 111: reference pattern for CheckRedirect usage)
</context>

<interfaces>
<!-- Key types and contracts the executor needs. -->

Item struct — add SSHKeyPath field after Protocol:
```go
// In pkg/warplib/item.go
type Item struct {
    // ... existing fields through Protocol ...
    Protocol Protocol `json:"protocol"`

    // SSHKeyPath is the path to the SSH private key used for SFTP downloads.
    // Persisted so resume uses the same key as the initial download.
    // Empty means default key paths (~/.ssh/id_ed25519, ~/.ssh/id_rsa) are tried.
    // GOB backward-compatible: missing field decodes as empty string (zero value).
    SSHKeyPath string `json:"ssh_key_path,omitempty"`

    // ... unexported fields (mu, dAllocMu, etc.) ...
}
```

AddDownloadOpts — add SSHKeyPath:
```go
// In pkg/warplib/manager.go
type AddDownloadOpts struct {
    IsHidden         bool
    IsChildren       bool
    ChildHash        string
    AbsoluteLocation string
    Priority         Priority
    SSHKeyPath       string // SSH key path to persist in Item for SFTP resume
}
```

AddProtocolDownload signature — unchanged, but body sets item.SSHKeyPath:
```go
func (m *Manager) AddProtocolDownload(pd ProtocolDownloader, probe ProbeResult, cleanURL string, proto Protocol, handlers *Handlers, opts *AddDownloadOpts) error {
    // ... existing code ...
    item.Protocol = proto
    item.SSHKeyPath = opts.SSHKeyPath  // NEW: persist SSH key path
    // ... rest unchanged ...
}
```

ResumeDownload SFTP branch — thread SSHKeyPath:
```go
// In ResumeDownload, ProtoFTP/ProtoFTPS/ProtoSFTP branch:
pd, err = m.schemeRouter.NewDownloader(item.Url, &DownloaderOpts{
    FileName:          item.Name,
    DownloadDirectory: item.DownloadLocation,
    SSHKeyPath:        item.SSHKeyPath,  // NEW: use persisted key
})
```

web.go processDownload — add CheckRedirect:
```go
client := &http.Client{
    Jar:           jar,
    CheckRedirect: warplib.RedirectPolicy(warplib.DefaultMaxRedirects),
}
```

Callers that need updating to pass SSHKeyPath in AddDownloadOpts:

1. internal/api/download.go (downloadProtocolHandler):
```go
err = s.manager.AddProtocolDownload(pd, probe, cleanURL, proto, handlers, &warplib.AddDownloadOpts{
    // ... existing fields ...
    SSHKeyPath: dlOpts.SSHKeyPath,  // NEW: from DownloaderOpts
})
```

2. internal/server/rpc_methods.go (downloadAdd):
```go
if err := rs.manager.AddProtocolDownload(pd, probe, cleanURL, proto, nil, &warplib.AddDownloadOpts{
    AbsoluteLocation: pd.GetDownloadDirectory(),
    SSHKeyPath:        p.SSHKeyPath,  // NEW: from AddParams
}); err != nil {
```
</interfaces>

<feature>
  <name>SFTP Resume SSH Key Persistence and web.go Redirect Policy</name>
  <files>pkg/warplib/item.go, pkg/warplib/manager.go, pkg/warplib/sftp_resume_key_test.go, internal/server/web.go, internal/server/web_redirect_test.go, internal/api/download.go, internal/server/rpc_methods.go</files>
  <behavior>
    Task 1 — SFTP SSH Key Persistence (SFTP-04, SFTP-06):

    RED phase — write failing tests in pkg/warplib/sftp_resume_key_test.go:

    TestSSHKeyPathGOBRoundTrip:
    - Create an Item with SSHKeyPath = "/custom/test/key"
    - GOB-encode it to a buffer
    - GOB-decode it back
    - Assert SSHKeyPath == "/custom/test/key"

    TestSSHKeyPathGOBBackwardCompat:
    - Decode the existing pre_phase2_userdata.warp fixture
    - Assert all decoded items have SSHKeyPath == "" (zero value, backward compat)

    TestSFTPResumePreservesCustomSSHKey:
    - Create a Manager with a mock SchemeRouter
    - Create a mock ProtocolDownloader factory that captures the DownloaderOpts
    - Add an SFTP item via AddProtocolDownload with SSHKeyPath="/custom/key" in AddDownloadOpts
    - Verify item.SSHKeyPath == "/custom/key" in the stored Item
    - Call ResumeDownload on the item
    - Verify the DownloaderOpts passed to NewDownloader has SSHKeyPath="/custom/key"

    TestSFTPResumeDefaultKeyWhenNone:
    - Same as above but with SSHKeyPath="" in AddDownloadOpts
    - Verify ResumeDownload passes SSHKeyPath="" to NewDownloader (triggering default key fallback)

    GREEN phase — implement the fix:

    1. Add SSHKeyPath field to Item struct in item.go (after Protocol field)
    2. Add SSHKeyPath field to AddDownloadOpts in manager.go
    3. In AddProtocolDownload: add `item.SSHKeyPath = opts.SSHKeyPath` after `item.Protocol = proto`
    4. In ResumeDownload (ProtoFTP/ProtoFTPS/ProtoSFTP branch): add `SSHKeyPath: item.SSHKeyPath` to the DownloaderOpts passed to NewDownloader
    5. Update callers:
       - internal/api/download.go: pass SSHKeyPath from dlOpts in AddDownloadOpts
       - internal/server/rpc_methods.go: pass SSHKeyPath from AddParams in AddDownloadOpts

    REFACTOR phase:
    - go fmt
    - go vet
    - Verify existing tests still pass

    Task 2 — web.go Redirect Policy (REDIR-04):

    RED phase — write failing test in internal/server/web_redirect_test.go:

    TestProcessDownload_CheckRedirectSet:
    - This test verifies the http.Client created in processDownload has CheckRedirect set
    - Since processDownload is a method on *WebServer and uses an http.Client internally,
      the test approach is to verify behavior: send a download request with a URL that
      redirects more than 10 times (exceeding DefaultMaxRedirects) and verify it fails
      with a redirect error rather than silently following all redirects
    - Alternative simpler approach: modify web.go to use a helper that's testable,
      or just test the behavior end-to-end

    Simpler approach — since processDownload creates the client inline and we can't easily
    intercept it, write a behavioral test:
    - Create an httptest server that always redirects (Location: self, 302)
    - Create a WebServer with a mock pool
    - Call processDownload with the redirect-loop URL
    - Assert error contains "redirect loop" (warplib.ErrTooManyRedirects)

    GREEN phase — add CheckRedirect to web.go line 56:
    ```go
    client := &http.Client{
        Jar:           jar,
        CheckRedirect: warplib.RedirectPolicy(warplib.DefaultMaxRedirects),
    }
    ```

    REFACTOR phase:
    - go fmt
    - go vet
    - Run all tests
  </behavior>
  <implementation>
    PHASE A (RED): Write failing tests

    Create pkg/warplib/sftp_resume_key_test.go:
    ```go
    package warplib

    import (
        "bytes"
        "context"
        "encoding/gob"
        "os"
        "sync"
        "testing"
    )

    func TestSSHKeyPathGOBRoundTrip(t *testing.T) {
        original := &Item{
            Hash:             "test-gob-ssh-key",
            Name:             "file.bin",
            Url:              "sftp://host/file.bin",
            SSHKeyPath:       "/custom/test/key",
            Protocol:         ProtoSFTP,
            Parts:            make(map[int64]*ItemPart),
        }

        var buf bytes.Buffer
        if err := gob.NewEncoder(&buf).Encode(original); err != nil {
            t.Fatalf("encode: %v", err)
        }

        var decoded Item
        if err := gob.NewDecoder(&buf).Decode(&decoded); err != nil {
            t.Fatalf("decode: %v", err)
        }

        if decoded.SSHKeyPath != "/custom/test/key" {
            t.Fatalf("expected SSHKeyPath '/custom/test/key', got %q", decoded.SSHKeyPath)
        }
        if decoded.Protocol != ProtoSFTP {
            t.Fatalf("expected ProtoSFTP, got %v", decoded.Protocol)
        }
    }

    func TestSSHKeyPathGOBBackwardCompat(t *testing.T) {
        // Decode the pre-Phase-2 fixture. It has no SSHKeyPath field.
        // The SSHKeyPath should decode as "" (zero value).
        data, err := os.ReadFile("testdata/pre_phase2_userdata.warp")
        if err != nil {
            t.Fatalf("read fixture: %v", err)
        }

        var items ItemsMap
        if err := gob.NewDecoder(bytes.NewReader(data)).Decode(&items); err != nil {
            // Try ManagerData format
            var md ManagerData
            if err2 := gob.NewDecoder(bytes.NewReader(data)).Decode(&md); err2 != nil {
                t.Fatalf("decode: %v (also tried legacy: %v)", err2, err)
            }
            items = md.Items
        }

        for hash, item := range items {
            if item.SSHKeyPath != "" {
                t.Errorf("item %s: expected empty SSHKeyPath, got %q", hash, item.SSHKeyPath)
            }
        }
    }

    // TestSFTPResumePreservesCustomSSHKey verifies that when an SFTP download
    // is added with a custom SSH key path, the key path is persisted in the Item
    // and threaded through to NewDownloader on resume.
    func TestSFTPResumePreservesCustomSSHKey(t *testing.T) {
        base := t.TempDir()
        if err := SetConfigDir(base); err != nil {
            t.Fatalf("SetConfigDir: %v", err)
        }
        m, err := InitManager()
        if err != nil {
            t.Fatalf("InitManager: %v", err)
        }
        defer m.Close()

        // Track what SSHKeyPath was passed to NewDownloader
        var capturedSSHKeyPath string
        mockFactory := func(rawURL string, opts *DownloaderOpts) (ProtocolDownloader, error) {
            capturedSSHKeyPath = opts.SSHKeyPath
            return &mockProtocolDownloader{
                hash:     "sftp-resume-test-hash",
                fileName: "file.bin",
                dlDir:    base,
            }, nil
        }

        router := NewSchemeRouter(nil)
        router.Register("sftp", mockFactory)
        m.SetSchemeRouter(router)

        // Create a mock protocol downloader for the initial add
        pd := &mockProtocolDownloader{
            hash:     "sftp-resume-test-hash",
            fileName: "file.bin",
            dlDir:    base,
        }

        // Add the download with SSHKeyPath
        err = m.AddProtocolDownload(pd, ProbeResult{
            FileName:      "file.bin",
            ContentLength: 1024,
            Resumable:     true,
        }, "sftp://host/file.bin", ProtoSFTP, &Handlers{}, &AddDownloadOpts{
            AbsoluteLocation: base,
            SSHKeyPath:       "/custom/key",
        })
        if err != nil {
            t.Fatalf("AddProtocolDownload: %v", err)
        }

        // Verify the stored item has SSHKeyPath
        item := m.GetItem("sftp-resume-test-hash")
        if item == nil {
            t.Fatal("item not found")
        }
        if item.SSHKeyPath != "/custom/key" {
            t.Fatalf("expected SSHKeyPath '/custom/key', got %q", item.SSHKeyPath)
        }

        // Stop the download to allow resume
        item.setDAlloc(nil)

        // Create dest file so resume integrity check passes
        destFile := item.GetAbsolutePath()
        os.MkdirAll(item.AbsoluteLocation, 0755)
        os.WriteFile(destFile, []byte("partial"), 0644)
        item.Downloaded = 7
        m.UpdateItem(item)

        // Resume the download
        _, err = m.ResumeDownload(nil, "sftp-resume-test-hash", &ResumeDownloadOpts{})
        if err != nil {
            t.Fatalf("ResumeDownload: %v", err)
        }

        // Verify the factory received the SSHKeyPath
        if capturedSSHKeyPath != "/custom/key" {
            t.Fatalf("expected NewDownloader to receive SSHKeyPath '/custom/key', got %q", capturedSSHKeyPath)
        }
    }

    func TestSFTPResumeDefaultKeyWhenNone(t *testing.T) {
        base := t.TempDir()
        if err := SetConfigDir(base); err != nil {
            t.Fatalf("SetConfigDir: %v", err)
        }
        m, err := InitManager()
        if err != nil {
            t.Fatalf("InitManager: %v", err)
        }
        defer m.Close()

        var capturedSSHKeyPath string
        mockFactory := func(rawURL string, opts *DownloaderOpts) (ProtocolDownloader, error) {
            capturedSSHKeyPath = opts.SSHKeyPath
            return &mockProtocolDownloader{
                hash:     "sftp-default-key-hash",
                fileName: "file.bin",
                dlDir:    base,
            }, nil
        }

        router := NewSchemeRouter(nil)
        router.Register("sftp", mockFactory)
        m.SetSchemeRouter(router)

        pd := &mockProtocolDownloader{
            hash:     "sftp-default-key-hash",
            fileName: "file.bin",
            dlDir:    base,
        }

        // Add with empty SSHKeyPath
        err = m.AddProtocolDownload(pd, ProbeResult{
            FileName:      "file.bin",
            ContentLength: 1024,
            Resumable:     true,
        }, "sftp://host/file.bin", ProtoSFTP, &Handlers{}, &AddDownloadOpts{
            AbsoluteLocation: base,
        })
        if err != nil {
            t.Fatalf("AddProtocolDownload: %v", err)
        }

        item := m.GetItem("sftp-default-key-hash")
        if item == nil {
            t.Fatal("item not found")
        }
        if item.SSHKeyPath != "" {
            t.Fatalf("expected empty SSHKeyPath, got %q", item.SSHKeyPath)
        }

        item.setDAlloc(nil)
        destFile := item.GetAbsolutePath()
        os.MkdirAll(item.AbsoluteLocation, 0755)
        os.WriteFile(destFile, []byte("partial"), 0644)
        item.Downloaded = 7
        m.UpdateItem(item)

        _, err = m.ResumeDownload(nil, "sftp-default-key-hash", &ResumeDownloadOpts{})
        if err != nil {
            t.Fatalf("ResumeDownload: %v", err)
        }

        if capturedSSHKeyPath != "" {
            t.Fatalf("expected empty SSHKeyPath on resume, got %q", capturedSSHKeyPath)
        }
    }

    // mockProtocolDownloader is a minimal mock for testing resume SSHKeyPath threading.
    type mockProtocolDownloader struct {
        hash     string
        fileName string
        dlDir    string
        stopped  bool
    }

    func (m *mockProtocolDownloader) Probe(_ context.Context) (ProbeResult, error) {
        return ProbeResult{FileName: m.fileName, ContentLength: 1024, Resumable: true}, nil
    }
    func (m *mockProtocolDownloader) Download(_ context.Context, _ *Handlers) error { return nil }
    func (m *mockProtocolDownloader) Resume(_ context.Context, _ map[int64]*ItemPart, _ *Handlers) error {
        return nil
    }
    func (m *mockProtocolDownloader) Capabilities() DownloadCapabilities {
        return DownloadCapabilities{SupportsResume: true}
    }
    func (m *mockProtocolDownloader) Close() error                { return nil }
    func (m *mockProtocolDownloader) Stop()                       { m.stopped = true }
    func (m *mockProtocolDownloader) IsStopped() bool             { return m.stopped }
    func (m *mockProtocolDownloader) GetMaxConnections() int32    { return 1 }
    func (m *mockProtocolDownloader) GetMaxParts() int32          { return 1 }
    func (m *mockProtocolDownloader) GetHash() string             { return m.hash }
    func (m *mockProtocolDownloader) GetFileName() string         { return m.fileName }
    func (m *mockProtocolDownloader) GetDownloadDirectory() string { return m.dlDir }
    func (m *mockProtocolDownloader) GetSavePath() string         { return m.dlDir + "/" + m.fileName }
    func (m *mockProtocolDownloader) GetContentLength() ContentLength { return 1024 }
    ```

    NOTE: The mock may need adjustment based on whether a similar mock already exists.
    Check for existing mockProtocolDownloader in the test files first. If it exists, reuse it.
    If it doesn't exist and there's a name collision, rename accordingly.

    Create internal/server/web_redirect_test.go:
    ```go
    package server

    import (
        "io"
        "log"
        "net/http"
        "net/http/httptest"
        "testing"

        "github.com/warpdl/warpdl/pkg/warplib"
    )

    // TestProcessDownload_RedirectLoopBlocked verifies that processDownload
    // enforces the redirect policy from Phase 1. A URL that creates a redirect
    // loop must fail with a redirect error, not loop indefinitely.
    func TestProcessDownload_RedirectLoopBlocked(t *testing.T) {
        // Create a server that always redirects to itself
        redirectCount := 0
        srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            redirectCount++
            http.Redirect(w, r, r.URL.String(), http.StatusFound)
        }))
        defer srv.Close()

        base := t.TempDir()
        if err := warplib.SetConfigDir(base); err != nil {
            t.Fatalf("SetConfigDir: %v", err)
        }
        m, err := warplib.InitManager()
        if err != nil {
            t.Fatalf("InitManager: %v", err)
        }
        defer m.Close()

        pool := NewPool(log.New(io.Discard, "", 0))
        ws := &WebServer{
            l:    log.New(io.Discard, "", 0),
            m:    m,
            pool: pool,
        }

        err = ws.processDownload(&capturedDownload{
            Url: srv.URL + "/redirect-loop.bin",
        })

        // Should fail because the redirect loop exceeds DefaultMaxRedirects
        if err == nil {
            t.Fatal("expected error from redirect loop, got nil")
        }

        // The error should come from warplib.RedirectPolicy (or Go's default 10-hop limit)
        // Before the fix, Go's default client follows up to 10 redirects silently.
        // After the fix, warplib.RedirectPolicy enforces the limit with a clear error.
        // Either way, the error should mention "redirect" or "stopped after".
        t.Logf("redirect error (expected): %v", err)
    }
    ```

    NOTE: The test above may need refinement. The key behavior change is that
    warplib.RedirectPolicy produces a specific error message vs Go's default.
    The test should verify the error contains "redirect loop" after the fix.

    PHASE B (GREEN): Implement fixes

    1. pkg/warplib/item.go:
       - Add SSHKeyPath field to Item struct after Protocol field

    2. pkg/warplib/manager.go:
       - Add SSHKeyPath field to AddDownloadOpts struct
       - In AddProtocolDownload, after `item.Protocol = proto`, add `item.SSHKeyPath = opts.SSHKeyPath`
       - In ResumeDownload, in the ProtoFTP/ProtoFTPS/ProtoSFTP branch, add `SSHKeyPath: item.SSHKeyPath` to the DownloaderOpts literal

    3. internal/api/download.go:
       - In downloadProtocolHandler, where AddProtocolDownload is called, add SSHKeyPath from the DownloaderOpts to AddDownloadOpts
       - Find where DownloaderOpts.SSHKeyPath is available (it comes from the CLI params) and thread it

    4. internal/server/rpc_methods.go:
       - In downloadAdd, in the protocol branch where AddProtocolDownload is called, add SSHKeyPath from AddParams to AddDownloadOpts

    5. internal/server/web.go:
       - Line 56: Change `client := &http.Client{Jar: jar}` to include `CheckRedirect: warplib.RedirectPolicy(warplib.DefaultMaxRedirects)`

    PHASE C (REFACTOR):
    - go fmt ./...
    - go vet ./...
    - Run all affected tests
    - Verify no regressions
  </implementation>
</feature>

<verification>
```bash
cd /Users/divkix/GitHub/warpdl/.claude/worktrees/issues-fix

# SFTP key persistence tests
go test -v -run "TestSSHKeyPath|TestSFTPResume" ./pkg/warplib/ -count=1

# Web redirect test
go test -v -run "TestProcessDownload_Redirect" ./internal/server/ -count=1

# All affected packages
go test -short ./pkg/warplib/... ./internal/server/... ./internal/api/... -count=1

# Race detection
go test -race -short ./pkg/warplib/... ./internal/server/... ./internal/api/... -count=1

# Full suite
go test ./... -count=1

# Build check
go build -ldflags='-w -s' .
```
</verification>

<success_criteria>
- Item struct has SSHKeyPath string field with correct json tag
- AddDownloadOpts has SSHKeyPath string field
- AddProtocolDownload sets item.SSHKeyPath = opts.SSHKeyPath
- ResumeDownload passes item.SSHKeyPath to NewDownloader for SFTP/FTP/FTPS
- GOB round-trip: SSHKeyPath survives encode/decode
- GOB backward compat: pre_phase2 fixture decodes with empty SSHKeyPath
- SFTP resume with custom key: NewDownloader receives the key path
- SFTP resume without custom key: NewDownloader receives empty string
- web.go processDownload http.Client has CheckRedirect set
- Redirect loop URL fails with warplib.RedirectPolicy error
- All existing tests pass (zero regression)
- Race detection clean
</success_criteria>

<output>
After completion, create `.planning/phases/06-fix-integration-defects/06-01-SUMMARY.md`
</output>
