---
phase: 01-http-redirect
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - pkg/warplib/redirect.go
  - pkg/warplib/redirect_test.go
  - pkg/warplib/dloader.go
  - pkg/warplib/errors.go
autonomous: true
requirements: [REDIR-01, REDIR-02, REDIR-03]

must_haves:
  truths:
    - "Downloading a URL that redirects through 301/302/303/307/308 completes successfully"
    - "After redirect chain resolves, d.url is updated to the final URL so all parallel segment requests use it"
    - "Redirect chain exceeding max hops (10) returns ErrTooManyRedirects with last URL in error message"
    - "Cross-protocol redirect (HTTP to FTP) is rejected with clear error"
  artifacts:
    - path: "pkg/warplib/redirect.go"
      provides: "Redirect policy function and related errors/constants"
      exports: ["RedirectPolicy", "DefaultMaxRedirects", "ErrTooManyRedirects", "ErrCrossProtocolRedirect"]
    - path: "pkg/warplib/redirect_test.go"
      provides: "Tests for redirect chain following, final URL capture, max hops, cross-protocol rejection"
  key_links:
    - from: "pkg/warplib/dloader.go:fetchInfo()"
      to: "d.url update after resp.Request.URL redirect resolution"
      via: "fetchInfo captures final URL from response"
      pattern: "resp\\.Request\\.URL\\.String\\(\\)"
    - from: "pkg/warplib/redirect.go:RedirectPolicy"
      to: "http.Client.CheckRedirect"
      via: "Client configuration"
      pattern: "CheckRedirect.*RedirectPolicy"
---

<objective>
Implement HTTP redirect following with final URL capture and max-hop enforcement.

Purpose: WarpDL currently stores the original URL in d.url and never updates it after redirect resolution. This means all parallel segment downloads (Range requests) hit the original URL, triggering redundant redirect chains. CDNs with signed/ephemeral redirect targets may fail or produce corrupted files. This plan fixes the core issue (REDIR-01, REDIR-02) and adds max-hop protection (REDIR-03).

Output: redirect.go with RedirectPolicy, updated fetchInfo() capturing final URL, and comprehensive tests.
</objective>

<execution_context>
@/Users/divkix/.claude/get-shit-done/workflows/execute-plan.md
@/Users/divkix/.claude/get-shit-done/templates/summary.md
@/Users/divkix/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/01-http-redirect/01-RESEARCH.md

@pkg/warplib/dloader.go
@pkg/warplib/parts.go
@pkg/warplib/errors.go
</context>

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From pkg/warplib/dloader.go:
```go
type Downloader struct {
    client *http.Client   // HTTP client used for all requests
    url    string         // URL of the file to download — THIS must be updated after redirect
    // ... other fields
}

// fetchInfo fetches file information. Currently calls makeRequest(GET) which follows
// redirects, but never updates d.url to the final URL.
func (d *Downloader) fetchInfo() (err error) { ... }

// makeRequest makes HTTP requests using d.url — all parts use this URL
func (d *Downloader) makeRequest(method string, hdrs ...Header) (*http.Response, error) { ... }

// NewDownloader creates a new downloader. Takes an *http.Client — this is where
// CheckRedirect should be configured.
func NewDownloader(client *http.Client, url string, opts *DownloaderOpts, optFuncs ...DownloaderOptsFunc) (d *Downloader, err error) { ... }
```

From pkg/warplib/errors.go:
```go
// Existing error vars — add new redirect errors alongside these
var (
    ErrContentLengthInvalid = errors.New("invalid content-length")
    ErrFileTooLarge         = errors.New("file too large")
    ErrFileExists           = errors.New("file exists")
    // ... more errors
)
```

From pkg/warplib/parts.go:
```go
// Part.download uses p.url for Range requests — this URL comes from d.url
// which is set during Downloader construction. After fetchInfo updates d.url,
// all subsequently spawned parts will use the final URL.
func (p *Part) download(headers Headers, ioff, foff int64, force bool, requestTimeout time.Duration) (body io.ReadCloser, slow bool, err error) { ... }
```
</interfaces>

<feature>
  <name>HTTP Redirect Following with Final URL Capture</name>
  <files>pkg/warplib/redirect.go, pkg/warplib/redirect_test.go, pkg/warplib/dloader.go, pkg/warplib/errors.go</files>
  <behavior>
    Test cases:
    1. URL with single 302 redirect: d.url updated to final URL, download completes
    2. URL with multi-hop redirect chain (301 -> 302 -> 200): d.url updated to final URL
    3. URL with 11 redirects (exceeds default 10): returns ErrTooManyRedirects with last URL in message
    4. Exactly 10 redirects: succeeds (boundary case)
    5. HTTP -> FTP redirect: returns ErrCrossProtocolRedirect
    6. All 3xx codes (301/302/303/307/308): each redirects and downloads correctly
    7. Redirect to different path on same host: works, URL updated
    8. No redirect (direct 200): d.url unchanged, works normally
    9. RedirectPolicy function returns nil for valid redirects within limit
    10. RedirectPolicy function returns error for over-limit redirects
  </behavior>
  <implementation>
    1. Create pkg/warplib/redirect.go:
       - DefaultMaxRedirects = 10
       - ErrTooManyRedirects = errors.New("redirect loop detected")
       - ErrCrossProtocolRedirect = errors.New("cross-protocol redirect not supported")
       - RedirectPolicy(maxRedirects int) func(*http.Request, []*http.Request) error
         - Counts hops via len(via)
         - Rejects if len(via) >= maxRedirects with error including last URL
         - Rejects if scheme changes from http/https to non-http/non-https
         - Returns nil otherwise

    2. Update pkg/warplib/dloader.go fetchInfo():
       - After d.makeRequest(http.MethodGet), check resp.Request.URL.String()
       - If different from d.url, update d.url to the final URL
       - This ensures prepareDownloader() and all subsequent part downloads use the final URL

    3. Update NewDownloader to set CheckRedirect on the client:
       - If client.CheckRedirect is nil, set it to RedirectPolicy(DefaultMaxRedirects)
       - Do NOT override if already set (respect caller's custom policy)

    4. Add error vars to errors.go (or keep in redirect.go — discretion)
  </implementation>
</feature>

<verification>
```bash
go test -v -run "TestRedirect" ./pkg/warplib/ -count=1
go test -race -short ./pkg/warplib/
go vet ./pkg/warplib/
```
</verification>

<success_criteria>
- RED: Failing tests exist for redirect following, final URL capture, max hops, cross-protocol rejection
- GREEN: All tests pass with minimal implementation
- REFACTOR: Code is clean, no duplication
- fetchInfo() updates d.url to final URL after redirect
- NewDownloader sets CheckRedirect if not already set
- RedirectPolicy enforces max hops with descriptive error
- Cross-protocol redirects rejected
- All existing tests still pass (zero regression)
</success_criteria>

<output>
After completion, create `.planning/phases/01-http-redirect/01-01-SUMMARY.md`
</output>
