# Progress: Download Queue Manager (issue-135)

## Status
**Phase**: Execution
**Created**: 2026-01-19

## Completed Tasks
- [x] 1.1 Write failing test for QueueManager.Add with capacity check
- [x] 1.2 Implement QueueManager struct and Add method
- [x] 1.3 Write failing test for OnComplete triggering next download
- [x] 1.4 Implement OnComplete and onStart callback
- [x] 1.5 Write failing test for Priority sorting
- [x] 1.6 Implement Priority type and priority-based dequeue
- [x] 1.7 Integrate QueueManager with Manager

## Reality Check (BEFORE)

**Goal type**: Add (new feature)
**No reproduction needed**: This is a feature addition, not a fix

## Current Task
Completed: 1.7 Integrate QueueManager with Manager

## Learnings

- Manager pattern uses GOB persistence with single file (`userdata.warp`)
- Test file created with NewQueueManager, Add, ActiveCount, WaitingCount, PriorityNormal APIs
- Handler callbacks are patched in `patchHandlers()` for progress tracking
- Pool tracks active downloads; pattern reusable for queue active set
- CLI follows urfave/cli pattern with subcommands in `cmd/ext/`
- API handlers return `(UpdateType, any, error)` tuple
- Client uses generic `invoke[T]` pattern for type-safe responses
- Race-free patterns: snapshot before iteration, single lock for TOCTOU prevention
- Existing Items have `dAlloc` field tracking active Downloader
- Priority constants: Low=0, Normal=1, High=2 (iota ordering)
- Priority insertion: Find first lower-priority item, insert before it. Maintains FIFO within same priority.
- Manager.AddDownload takes Downloader, API layer calls d.Start() separately
- Queue integration: AddDownload registers with queue, DownloadCompleteHandler notifies queue.OnComplete
- onStart callback is external (passed to SetMaxConcurrentDownloads) - daemon/API layer provides implementation
- item.Hash is the download identifier, distinct from MAIN_HASH used in completion handlers

## Decisions Made

1. **Unified persistence**: Queue state stored alongside items in same GOB file
2. **Sorted slice for priority**: Simple impl, queue size expected to be small
3. **Callback pattern**: Use onStart callback to match existing handler pattern
4. **Default limit 3**: Balance between bandwidth utilization and parallelism

## Open Questions

- Consider channel-based slot notification for better decoupling?
- Batched persistence for high-frequency operations?

## Files Generated

| File | Summary |
|------|---------|
| research.md | Feasibility: High, patterns exist |
| requirements.md | 7 user stories, 10 FRs, 6 NFRs |
| design.md | QueueManager component, integration plan |
| tasks.md | 24 tasks, 4 phases, TDD structure |

## Next
Task 1.8: Add --max-concurrent flag to daemon
