# Progress: Download Queue Manager (issue-135)

## Status
**Phase**: Execution
**Created**: 2026-01-19

## Completed Tasks
- [x] 1.1 Write failing test for QueueManager.Add with capacity check
- [x] 1.2 Implement QueueManager struct and Add method
- [x] 1.3 Write failing test for OnComplete triggering next download
- [x] 1.4 Implement OnComplete and onStart callback

## Reality Check (BEFORE)

**Goal type**: Add (new feature)
**No reproduction needed**: This is a feature addition, not a fix

## Current Task
Awaiting next task

## Learnings

- Manager pattern uses GOB persistence with single file (`userdata.warp`)
- Test file created with NewQueueManager, Add, ActiveCount, WaitingCount, PriorityNormal APIs
- Handler callbacks are patched in `patchHandlers()` for progress tracking
- Pool tracks active downloads; pattern reusable for queue active set
- CLI follows urfave/cli pattern with subcommands in `cmd/ext/`
- API handlers return `(UpdateType, any, error)` tuple
- Client uses generic `invoke[T]` pattern for type-safe responses
- Race-free patterns: snapshot before iteration, single lock for TOCTOU prevention
- Existing Items have `dAlloc` field tracking active Downloader

## Decisions Made

1. **Unified persistence**: Queue state stored alongside items in same GOB file
2. **Sorted slice for priority**: Simple impl, queue size expected to be small
3. **Callback pattern**: Use onStart callback to match existing handler pattern
4. **Default limit 3**: Balance between bandwidth utilization and parallelism

## Open Questions

- Consider channel-based slot notification for better decoupling?
- Batched persistence for high-frequency operations?

## Files Generated

| File | Summary |
|------|---------|
| research.md | Feasibility: High, patterns exist |
| requirements.md | 7 user stories, 10 FRs, 6 NFRs |
| design.md | QueueManager component, integration plan |
| tasks.md | 24 tasks, 4 phases, TDD structure |

## Next
Task 1.5: Write failing test for Priority sorting
