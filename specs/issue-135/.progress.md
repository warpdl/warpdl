# Progress: Download Queue Manager (issue-135)

## Status
**Phase**: Execution
**Created**: 2026-01-19

## Completed Tasks
- [x] 1.1 Write failing test for QueueManager.Add with capacity check
- [x] 1.2 Implement QueueManager struct and Add method
- [x] 1.3 Write failing test for OnComplete triggering next download
- [x] 1.4 Implement OnComplete and onStart callback
- [x] 1.5 Write failing test for Priority sorting
- [x] 1.6 Implement Priority type and priority-based dequeue
- [x] 1.7 Integrate QueueManager with Manager
- [x] 1.8 Add --max-concurrent flag to daemon
- [x] 1.9 POC Checkpoint - End-to-end queue verification
- [x] 2.1 Add queue state persistence
- [x] 2.2 Implement Pause/Resume methods

## Reality Check (BEFORE)

**Goal type**: Add (new feature)
**No reproduction needed**: This is a feature addition, not a fix

## Current Task
Completed: 2.2 Implement Pause/Resume methods

## Learnings

- Manager pattern uses GOB persistence with single file (`userdata.warp`)
- Test file created with NewQueueManager, Add, ActiveCount, WaitingCount, PriorityNormal APIs
- Handler callbacks are patched in `patchHandlers()` for progress tracking
- Pool tracks active downloads; pattern reusable for queue active set
- CLI follows urfave/cli pattern with subcommands in `cmd/ext/`
- API handlers return `(UpdateType, any, error)` tuple
- Client uses generic `invoke[T]` pattern for type-safe responses
- Race-free patterns: snapshot before iteration, single lock for TOCTOU prevention
- Existing Items have `dAlloc` field tracking active Downloader
- Priority constants: Low=0, Normal=1, High=2 (iota ordering)
- Priority insertion: Find first lower-priority item, insert before it. Maintains FIFO within same priority.
- Manager.AddDownload takes Downloader, API layer calls d.Start() separately
- Queue integration: AddDownload registers with queue, DownloadCompleteHandler notifies queue.OnComplete
- onStart callback is external (passed to SetMaxConcurrentDownloads) - daemon/API layer provides implementation
- item.Hash is the download identifier, distinct from MAIN_HASH used in completion handlers
- initDaemonComponents is a package-level var to allow test mocking
- Windows service mode has no CLI context, reads env vars directly for config
- urfave/cli automatically reads EnvVar when flag not provided on CLI
- E2E queue verification uses simulated completions via queue.OnComplete() - matches real DownloadCompleteHandler behavior
- Integration test verifies: queue limits respected, auto-start on completion, priority ordering, Manager integration
- Test pattern: newE2ETestServer() serves HTTP range requests for realistic download simulation
- Queue persistence: QueueState struct with exported fields for GOB (QueuedItemState for waiting items)
- ManagerData wrapper struct holds both Items and QueueState for unified persistence
- Backward compatibility: InitManager tries new format first, falls back to legacy ItemsMap-only format
- SetMaxConcurrentDownloads restores persisted queue state via LoadState(), preserving waiting items across restart
- Active items not persisted (re-queued on restart) - only waiting items survive daemon restart
- Pause/Resume: `paused` field blocks auto-start in OnComplete, Resume() starts waiting items up to capacity
- QueueState includes Paused field for persistence, LoadState restores paused state

## Decisions Made

1. **Unified persistence**: Queue state stored alongside items in same GOB file
2. **Sorted slice for priority**: Simple impl, queue size expected to be small
3. **Callback pattern**: Use onStart callback to match existing handler pattern
4. **Default limit 3**: Balance between bandwidth utilization and parallelism

## Open Questions

- Consider channel-based slot notification for better decoupling?
- Batched persistence for high-frequency operations?

## Files Generated

| File | Summary |
|------|---------|
| research.md | Feasibility: High, patterns exist |
| requirements.md | 7 user stories, 10 FRs, 6 NFRs |
| design.md | QueueManager component, integration plan |
| tasks.md | 24 tasks, 4 phases, TDD structure |

## Next
Task 2.3: Implement Move method
