# Progress: Download Queue Manager (issue-135)

## Status
**Phase**: Execution
**Created**: 2026-01-19

## Completed Tasks
- [x] 1.1 Write failing test for QueueManager.Add with capacity check
- [x] 1.2 Implement QueueManager struct and Add method
- [x] 1.3 Write failing test for OnComplete triggering next download
- [x] 1.4 Implement OnComplete and onStart callback
- [x] 1.5 Write failing test for Priority sorting
- [x] 1.6 Implement Priority type and priority-based dequeue
- [x] 1.7 Integrate QueueManager with Manager
- [x] 1.8 Add --max-concurrent flag to daemon
- [x] 1.9 POC Checkpoint - End-to-end queue verification
- [x] 2.1 Add queue state persistence
- [x] 2.2 Implement Pause/Resume methods
- [x] 2.3 Implement Move method
- [x] 2.4 Add common types for queue API
- [x] 2.5 Implement queue API handlers
- [x] 2.6 Add queue client methods
- [x] 2.7 Implement CLI queue command
- [x] 2.8 Add --priority flag to download command
- [x] 2.9 Add error handling and validation - verified existing
- [x] 3.1 Unit tests for QueueManager edge cases
- [x] 3.2 Race condition tests for QueueManager
- [x] 3.3 API handler tests
- [x] 3.4 Integration test for queue persistence - verified existing

## Reality Check (BEFORE)

**Goal type**: Add (new feature)
**No reproduction needed**: This is a feature addition, not a fix

## Current Task
Task 3.4 Integration test for queue persistence - DONE (verified existing)

## Learnings

- Manager pattern uses GOB persistence with single file (`userdata.warp`)
- Test file created with NewQueueManager, Add, ActiveCount, WaitingCount, PriorityNormal APIs
- Handler callbacks are patched in `patchHandlers()` for progress tracking
- Pool tracks active downloads; pattern reusable for queue active set
- CLI follows urfave/cli pattern with subcommands in `cmd/ext/`
- API handlers return `(UpdateType, any, error)` tuple
- Client uses generic `invoke[T]` pattern for type-safe responses
- Race-free patterns: snapshot before iteration, single lock for TOCTOU prevention
- Existing Items have `dAlloc` field tracking active Downloader
- Priority constants: Low=0, Normal=1, High=2 (iota ordering)
- Priority insertion: Find first lower-priority item, insert before it. Maintains FIFO within same priority.
- Manager.AddDownload takes Downloader, API layer calls d.Start() separately
- Queue integration: AddDownload registers with queue, DownloadCompleteHandler notifies queue.OnComplete
- onStart callback is external (passed to SetMaxConcurrentDownloads) - daemon/API layer provides implementation
- item.Hash is the download identifier, distinct from MAIN_HASH used in completion handlers
- initDaemonComponents is a package-level var to allow test mocking
- Windows service mode has no CLI context, reads env vars directly for config
- urfave/cli automatically reads EnvVar when flag not provided on CLI
- E2E queue verification uses simulated completions via queue.OnComplete() - matches real DownloadCompleteHandler behavior
- Integration test verifies: queue limits respected, auto-start on completion, priority ordering, Manager integration
- Test pattern: newE2ETestServer() serves HTTP range requests for realistic download simulation
- Queue persistence: QueueState struct with exported fields for GOB (QueuedItemState for waiting items)
- ManagerData wrapper struct holds both Items and QueueState for unified persistence
- Backward compatibility: InitManager tries new format first, falls back to legacy ItemsMap-only format
- SetMaxConcurrentDownloads restores persisted queue state via LoadState(), preserving waiting items across restart
- Active items not persisted (re-queued on restart) - only waiting items survive daemon restart
- Pause/Resume: `paused` field blocks auto-start in OnComplete, Resume() starts waiting items up to capacity
- QueueState includes Paused field for persistence, LoadState restores paused state
- Move method: extract item, remove from old position, insert at new position. Clamp position to [0, len-1]. Error types: ErrQueueHashNotFound, ErrCannotMoveActive
- API handlers need GetActiveHashes/GetWaitingItems methods added to QueueManager - not originally exposed
- Queue API handlers check if queue is nil (not enabled) and return appropriate error or empty response
- Priority flag chain: CLI --priority -> warpcli.DownloadOpts.Priority -> common.DownloadParams.Priority -> warplib.AddDownloadOpts.Priority -> queue.Add(hash, priority)
- Priority values: 0=low, 1=normal, 2=high (matches warplib.Priority constants)
- Edge case tests: Resume only starts waiting items if capacity available (must complete one first to free slot)
- 100% coverage on queue.go achieved with edge case tests for: empty queue, single item, maxConcurrent=1, boundary positions, idempotent ops, concurrent modifications
- Race tests: dedicate separate file (queue_race_test.go) for -race flag tests. Cover concurrent Add, OnComplete, Move, Pause/Resume, LoadState, and mixed operations. No assertions needed - pass if no race detected
- API handler tests: Use `newTestApiWithQueue()` helper that calls `SetMaxConcurrentDownloads` to enable queue. Test nil queue cases return "queue not enabled" error. Queue handlers accept nil sconn/pool params since they don't use connections

## Decisions Made

1. **Unified persistence**: Queue state stored alongside items in same GOB file
2. **Sorted slice for priority**: Simple impl, queue size expected to be small
3. **Callback pattern**: Use onStart callback to match existing handler pattern
4. **Default limit 3**: Balance between bandwidth utilization and parallelism

## Open Questions

- Consider channel-based slot notification for better decoupling?
- Batched persistence for high-frequency operations?

## Files Generated

| File | Summary |
|------|---------|
| research.md | Feasibility: High, patterns exist |
| requirements.md | 7 user stories, 10 FRs, 6 NFRs |
| design.md | QueueManager component, integration plan |
| tasks.md | 24 tasks, 4 phases, TDD structure |

## Next
Task 4.1: Coverage check
